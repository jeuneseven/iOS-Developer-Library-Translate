[View Controller Programming Guide for iOS 原文链接](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)

# 概览
## 视图控制器所扮演的角色
视图控制器是你的应用程序内部架构的基础。每个应用程序都至少含有一个视图控制器，大部分应用程序都有很多个。每个应用程序都会管理着一份你的应用程序的用户界面以及该用户界面与底层数据的交互。视图控制器同样也会改善不同的视图界面之间转换的过渡。  
由于它在你的应用程序当中扮演着如此重要的角色，视图控制器几乎会成为你做任何事的中心。UIViewController类定义了很多方法和属性来管理你的视图，处理事件，从一个视图控制器过渡到另一个以及协调你的应用程序的其他部分。你可以继承UIViewController（或者集成它的子类）然后添加自己需要实现的行为的代码即可。  
一共有两种类型的视图控制器：  

* 内容类的视图控制器管理着你的应用程序的分散的内容，它是你主要创建的视图控制器。
* 容器类视图控制器从其他的视图控制器收集信息（被称作子视图控制器）以一种简便的导航方式展示出来或者以不同的模态方式展示这些视图控制器的内容。

大部分应用程序是这两种类型视图控制器的混合体。
### 视图的管理
一个视图控制器的最重要的角色是管理视图的层级。每个视图控制器都拥有一个根视图，它将所有的视图控制器的内容都封装进去。通过这个根视图，你可以添加你需要展示的视图内容。图1-1展示了视图控制器和它的视图之间的内部关系。视图控制器将一直持有根视图，并且每个视图对于它的子视图都是强引用。  

图1-1 视图控制器和它的视图之间的关系  

![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_ControllerHierarchy_fig_1-1_2x.png)

	注意：通常使用outlets来访问在你的视图控制器层级当中的其它视图。由于一个视图控制器管理着所有它的视图的内容，outlets能够让你持有你需要的视图的引用。outlets本身在视图被从故事版加载的时候自动连接到了实际的视图对象。  

内容类的视图控制器通过它本身来管理所有的视图。容器类的视图控制器管理它本身的视图以及一个或多个子视图的根视图。容器类本身不会管理它的子视图的内容。它仅仅管理根视图，尺寸并根据容器的设计来布局。图1-2展示了一个split视图控制器以及它的子视图之间的关系。split视图控制器管理了它的子视图的总体尺寸和位置，但是子视图控制器管理了这些视图的实际内容。

图1-2 视图控制器能够管理其它视图控制器的内容

![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_ContainerViewController_fig_1-2_2x.png)  

更多关于管理你的视图控制器视图的相关信息，参见“管理视图布局”。

### 数据的封装
一个视图控制器在它管理的视图和你的应用程序的数据之间起到了一个调度的作用。UIViewController类的方法和属性能够让你管理你的应用程序的可视化部分。当你继承UIViewController类的时候，你可以添加任何你需要管理你的数据的变量到你的子类当中。添加一个自定义的变量回创建一个类似于图1-3当中的关系，当视图控制器持有你的数据，视图将会用它来展示那个数据。将数据从两者之间进行传递是你的责任。  

图1-3 一个视图控制器在数据对象和视图对象之间进行调度

![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_CustomSubclasses_fig_1-3_2x.png)

你应当在你的视图控制器和数据对象之间始终维护一个清晰的责任关系。大部分确认数据结构完整性的逻辑都应该在数据对象当中实现。视图控制器可能会需要验证从视图当中输入的内容，然后将其打包成你的数据需要的格式，但是你应该确保视图控制器在管理实际数据的过程中担任尽量少的角色。  
UIDocument对象是一种能够让数据与你的视图控制器分离的管理方式。文档对象是一个控制器对象，它知道如何永久存储一个可读写的数据。当你继承它时，你可以添加任何你需要的逻辑和方法来处理数据，你可以将其传递到一个视图控制器或者你的应用程序的其他部分。视图控制器可能会保留一份它接收到的数据的拷贝，以便将其更容易的更新到视图上，不过文档本身还是拥有实际的数据。
### 用户的交互
视图控制器是响应类型的对象，并且能够处理从响应者链条中传递过来的事件。尽管它能够这么做，但是视图控制器很少直接处理触摸事件。通常，是由视图来处理它们本身的触摸事件，然后将其结果发送给一个相关的代理方法或者目标对象，通常是一个视图控制器。所以大部分在视图控制器当中的事件都是使用代理方法或者目标函数来处理的。  
更多关于在视图控制器当中实现目标函数的相关信息，参见“处理用户交互”。更多关于处理其他类型的事件的相关信息，参见“iOS事件处理指南”。
### 资源的管理
视图控制器对其视图及其创建的任何对象承担全部责任。UIViewController类会自动的处理视图管理的大部分内容。举例来说，UIKit自动处理不再需要的视图相关的资源。在你的UIViewController子类当中，你应当管理所有由你创建的对象。  
当可用的内存较少的时候，UIKit会要求应用程序释放任何不再需要的资源。其中一种方式是调用你的视图控制器当中的didReceiveMemoryWarning方法。使用该方法来移除你不再需要的对象的引用或在以后重新创建。比如，你可以使用该方法移除缓存的数据。当发生低内存警告的时候，尽你所能的释放更多的内存是很重要的。应用程序如果消耗过多的内存的话，可能会被系统完全终止来释放内存。
### 自适应性
视图控制器要负责展示它的视图，并且要适配那些展示的视图来匹配底层环境。每款iOS的应用程序都应该能够运行在iPad上以及不同尺寸的iPhone手机上。使用一个单一的视图控制器来适配它的视图来改变空间所需更为简单，而不是为不同的设备提供很多的视图控制器和视图层级。  
在iOS上，视图控制器要处理各种粗细粒度的尺寸变更。当一个视图控制器的特性发生改变的时候会有粗粒度的变更。特性是用来描述整体环境的一种属性，比如展示的缩放。视图控制器有两个非常重要的特性就是垂直方向和水平方向的尺寸控制类，它们表示视图控制器在给定的尺寸当中有多少空间能够用来展示。你可以使用尺寸类的变更来作为改变你的视图布局的方式，如图1-4所示。当水平尺寸控制类为regular（分散对齐）的时候，视图控制器会利用额外的水平空间来布局它的内容。当水平尺寸控制类为compact（紧凑对齐）的时候，视图控制器会对其内容进行垂直布局。  

图1-4 适配视图来进行尺寸类变更
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_SizeClassChanges_fig_1-4_2x.png)  

在一个给定的尺寸类当中，随时都会发生很多的细粒度的尺寸变更。当用户将iPhone从竖直方向转为水平方向，尺寸类可能不会改变，而屏幕的尺寸通常会变更。当你使用自动布局的时候，UIKit自动的调整视图的尺寸和位置来匹配新的尺寸。视图控制器可以根据需要来进行额外的调整。  
更多关于自适应性的相关信息，参见“自适应模型”。
## 视图控制器的层级结构
你的应用程序当中的视图控制器之间的关系定义了每个视图控制器所需要的行为。UIKit框架期望你以规定的方式来使用视图控制器。维持视图控制器之间适当的关系，确保在视图控制器被需要的时候能够自动调用适当的行为发送给对应的视图控制器。如果你打破了规定的包含和展示关系，你的应用程序的某些部分将会不出意外的停止某些行为。
### 根视图控制器
根视图控制器是视图控制器层级的根节点。每个窗口都拥有一个根视图控制器，它的内容会填充该窗口。根视图控制器定义了最初能够被用户所见的内容。图2-1展示了根视图控制器和窗口之前的关系。由于窗口本身没有能够展示的内容，视图控制器的视图提供了所有它的内容来展示。  

图2-1 根视图控制器
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG-root-view-controller_2-1_2x.png)  

UIWindow对象的rootViewController属性可以用来让根视图控制器访问。当你使用故事版来配置你的视图控制器的时候，UIKit会在启动的时候自动的设置这个属性的值。对于代码创建的窗口而言，你必须自己设置根视图控制器。
### 容器视图控制器
容器视图控制器使您可以从更易于管理和可重用的部分组装复杂的接口。一个容器视图控制器结合了一个或多个子视图控制器和一些自定义的视图内容来创建最终的界面。举例来说，一个UINavigationController对象展示了一个子视图控制器的内容和一个导航栏以及一个可选的工具栏，它们都是被导航控制器所管理的。UIKit包含了多种容器类的视图控制器，包括UINavigationController，UISplitViewController， 和 UIPageViewController。  
一个容器类视图控制器的视图会将给予它的空间全部填满。容器视图控制器通常在一个窗口当中作为根视图控制器（如图2-2所示），不过它们同样可以被模态展示或者作为其他容器的子视图控制器。容器负责将它的子视图布置到合适的位置。在视图当中，容器将两个子视图并排放置。尽管它依附于容器界面，子视图控制器会尽少的和容器以及并排的视图控制器关联。

图2-2 容器扮演根视图控制器的角色  
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG-container-acting-as-root-view-controller_2-2_2x.png)

由于容器视图控制器管理着它的子类，UIKit为如何在自定义容器中设置这些子类定义了规则。关于如何创建一个自定义容器视图控制器的详细信息，参见“实现一个容器视图控制器”。
### 展现视图控制器
展现一个视图控制器会用它的新的内容取代当前视图控制器的内容，通常会隐藏之前视图控制器的内容。展示的形式通常用于展现新内容模式。举例来说，你可能会展示一个视图控制器来收集用户的输入。你还可以使用它来作为你的应用程序界面的一个通用的构建模块。  
当你展现一个视图控制器的时候，UIKit会在展现的的视图控制器和被展现的视图控制器之间建立关系，如图2-3所示。(这在从被展现的视图控制器返回展现的视图控制器之间是一对相反的关系。)这种关系是组成视图控制器层级关系的一部分，同样也是在运行时定位其他视图控制器的一种方式。  

图2-3 展现视图控制器
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG-presented-view-controllers_2-3_2x.png)  

当有容器类视图控制器参与的时候，UIKit可能会修改展示链来简化你必须编写的代码。不同的展现样式会有不同的规则来决定它们如何被展示在屏幕上——举例来说，全屏的展现通常会覆盖整个屏幕。当你展现一个视图控制器的时候，UIKit会找到一个提供合适上下文的视图控制器用来展现。在大多数情况下，UIKit会选择最近的容器视图控制器，不过也可能会选择窗口的根视图控制器。在某些情况下，你还能够告诉UIKit哪个视图控制器定义了展现的上下文，并且它应该处理展现的逻辑。  
图2-4展示了为什么容器通常会为展现提供上下文。当执行全屏幕展现的时候，新的视图控制器需要覆盖整个屏幕。容器决定是否处理展现逻辑，子视图无需知道它的容器的边界。由于示例中的导航控制器涵盖整个屏幕, 因此它充当呈现视图控制器并负责初始化展现逻辑。

图2-4 一个容器和一个展现的视图控制器
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG-container-and-presented-view-controller_2-4_2x.png)  

更多关于展现的相关信息，参见“展现和转换过程”部分。
## 设计指南
视图控制器作为应用程序运行在iOS上的基本工具，UIKit对于视图控制器的基本架构使得创建复杂界面极为简单，而无需编写大量的代码。当实现你自己的视图控制器的时候，请采取以下的建议和指南以确保您不会执行可能干扰系统所期望的自然行为的操作。
### 尽量使用系统支持的视图控制器
很多iOS的框架都定义了视图控制器来让你用在你的应用程序当中。使用这些系统提供的视图控制器能够节省你的时间，并且能够为用户提供始终如一的体验。  
大部分系统的视图控制器都是为特定任务设计的。某些视图控制器提供访问用户的数据功能，比如通讯录。还有的视图控制器会提供访问硬件的功能，或者提供对于媒体管理进行相关调试的界面。比如UIKit当中的UIImagePickerController类展示了一个标准界面来拍摄照片和视频，并且可以用它来访问用户的相机胶卷。  
在你创建你自定义的视图控制器之前，最好先查看一下已有的框架当中是否存在你要执行的任务的相关视图控制器。  

* UIKit框架提供了视图控制器来展示警告框，拍摄视频和照片以及管理在iCloud上的文件。UIKit同样定义了很多容器视图控制器，你可以用来管理你的内容。
* GameKit提供了视图控制器来匹配玩家和管理排行榜，成就榜以及其它游戏相关的功能。
* Address Book UI（地址簿）框架提供了视图控制器来展示和选择通讯录相关信息。
* MediaPlayer（媒体）框架提供了视图控制器来播放和管理视频，还可以通过它来选择用户相册中的媒体数据。
* EventKit UI（日历）框架提供了视图控制器来展示和编辑用户的日历数据。
* GLKit框架提供了视图控制器来管理OpenGL渲染层。
* Multipeer Connectivity（多点连接）框架提供了视图控制器来检测其它用户的状态，并邀请连接。
* Message UI（消息）框架提供了视图控制器来编写邮件和短信息。
* PassKit框架提供了视图控制器展示护照和添加护照到护照本当中。
* Social框架提供了视图控制器来为twitter，Facebook和其它的社交媒体的发布信息进行排版。
* AVFoundation框架提供了视图控制器来展示媒体数据。
	
> 重要  
> 永远不要修改系统提供的视图控制器的视图层级。每个视图控制器都有它自己的视图层级，并且它会负责维护该层级的完整性。进行更改可能会将 bug 引入到代码中, 或阻止拥有视图控制器正常运行。在使用系统提供的视图控制器的时候，你应当一直依赖使用视图控制器提供的公共方法和属性来进行修改。

更多的使用特定的视图控制器的相关信息，参见相应的框架的相关文档。

### 尽量使每个视图控制器孤立
视图控制器应当始终是一个独立的对象。任何视图控制器都不应该知晓其它的视图控制器的内部工作以及视图结构。在两个视图控制器需要交互或者来回传递数据的情况下，它们应当使用明确定义的公共接口来做这件事。  
代理模式会在视图控制器的交互管理当中被频繁的使用。通过代理方式，一个对象会定义一个协议来与它相关的代理对象通信，任何对象都可以遵循协议。代理对象的类型的确定性并不重要。重要的是它实现了协议中的方法。
### 使用根视图的时候，将其仅作为其它视图的容器
应当使用你的视图控制器的根视图仅仅作为你的内容的容器。使用根视图作为容器会让你的视图拥有一个共用的父视图，这会让很多布局操作更为简单。很多自动布局的约束需要一个共用的父视图来对视图进行适当的布局。
### 要知晓你的数据的生命周期
在模型－视图－控制器这种设计模式当中，视图控制器所扮演的角色是促进数据在你的模型对象和你的视图对象之间移动。一个视图控制器可能会存储某些临时变量数据或者执行某些验证，但是它的主要责任是确保它的视图包含了确定的信息。你的数据对象要负责管理实际的数据，并且确保那些数据的完整性。  
一个数据与界面分离的例子是 UIDocument 和 UIViewController 类之间的关系。特别的是，没有默认的关系存在于它们两者之间。当一个UIViewController对象展示视图到屏幕上的时候，UIDocument对象负责加载和保存数据。当你在这两个对象之间建立联系的时候，要记住，视图控制器只为了效率才从document缓存信息。实际的数据依旧属于document对象。
### 要适应改变
应用程序很可能运行在各种iOS设备上，那么视图控制器也会被设计成适应不同尺寸的设备的屏幕。你可以使用你的视图控制器中内置的适配支持来响应尺寸类的变更，而无需使用不同的视图控制器来管理不同屏幕上的内容。UIKit会发送通知来给你适当的机会来放大或缩小来改变你的用户界面，而无需改变你的视图控制器当中的其它的代码。  
更多关于适配变更的相关信息，参见“适配模型”。
# 视图控制器的定义
## 定义你的子类
使用 UIViewController 的子类来展示你的应用程序的内容。大部分自定义的视图控制器都是内容视图控制器——意思是它们拥有所有相关视图和负责这些视图上的数据展示。相比之下，容器视图控制器不拥有全部的相关视图；这些视图当中的一部分被其他的视图控制器管理。定义内容类和容器类视图控制器的大部分步骤都是类似的，这会在后续章节当中进行讨论。  
对于内容视图控制器，比较通用的父类是以下几种：  

* 你的视图控制器主要是展示一个列表的时候，继承UITableViewController
* 你的视图控制器主要是展示一个表格的时候，继承UICollectionViewController
* 对于其他的视图控制器继承UIViewController

对于容器类视图控制器，父类取决于你是在修改一个已经存在的容器类还是创建你自己的。对于已经存在的容器，你可以任意选择已经存在的容器类来修改。对于你创建的新的容器视图控制器，通常继承于UIViewController。关于创建一个容器视图控制器的相关信息，参见“实现一个容器类视图控制器”。
### 定义你的UI
你可以使用Xcode的故事版来为你的视图控制器可视化的定制UI。尽管你可以使用代码的方式创建你的UI界面，但是故事版是一种非常好的方式来可视化的编辑你的视图控制器的内容，并且可以根据不同的环境定制视图层级（根据需要）。可视化的构建UI界面，能让你更快速的响应变化，让你无需构建和运行你的应用程序就能够看到结果。  
图4-1展示了一个故事版的例子。每个矩形的区域都代表了一个视图控制器以及它关联的视图。视图控制器之间的箭头代表了视图控制器的关系和转场。Relationships链接了一个容器视图控制器和它的子视图控制器。Segues让你能够在你的界面当中在视图控制器之间导航。    

图4-1 故事版处理一批视图控制器和视图
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/storyboard_bird_sightings_2x.png)  

每个新建的工程都会有一个主故事版，它通常会包含一个或多个视图控制器。你可以通过从库中拖拽一个新的视图控制器到你的故事版中达到添加的目的。新的视图控制器在创建的时候不会关联它的相关类，所以你必须使用身份匹配功能来为它赋值。  
使用故事版编辑器可以做以下功能：  

* 为视图控制器的视图添加，调整以及配置。
* 连接接口和行为；参见“处理用户交互”。
* 在视图控制器之间创建关系和转场；参见“使用Segues”。
* 为不同的尺寸类定制布局和视图；参见“构建一个适配的界面”。
* 添加手势识别来处理用户与视图之间的交互；参见“iOS事件处理指南”。

如果你是使用故事版来构建你的界面的新手，你可以在“从现在开始开发iOS应用程序”中找到创建基于故事版的界面的步骤说明。
### 处理用户的交互
一款应用程序的响应者对象会处理外来事件并给予合适的执行方法。尽管视图控制器就是响应者对象，但它们很少直接处理触摸事件。通常，视图控制器会以以下几种方式来处理事件。  

* 视图控制器会定义响应方法来处理高优先级的事件。响应方法会响应：  
	* 指定的事件。控件和其他的视图会调用响应方法来报告指定的交互。
	* 手势。手势会调用一个响应方法来报告当前的手势状态。使用你的视图控制器来处理手势的状态变更或者响应完整的手势。
* 视图控制器会监听由系统或其他对象发出的通知。通知会报告状态的变化，这是视图控制器更新状态的一种时机。
* 视图控制器会担当其他对象的数据源或者代理。视图控制器通常被用来管理列表和表单视图的数据。你还可以使用它来作为一个对象（例如 CLLocationManager 对象）的代理，后者会发送地理位置的更新数据给它的代理。  

响应事件通常包含更新视图的内容，这需要关联这些视图。你的视图控制器是定义你稍后要修改的视图的绝佳位置。使用清单4-1当中的语句来声明你的outlets作为属性。清单中的自定义类定义了两个outlets（被称作IBOutlet关键字）以及一个动作方法（被称作IBAction返回类型）。outlets存储在故事版当中，关联到了一个按钮和一个输入框，动作方法会响应按钮的点击。  

清单4-1 在视图控制器类中定义outlets和actions  

> OBJECTIVE-C  
> @interface MyViewController : UIViewController  
> @property (weak, nonatomic) IBOutlet UIButton *myButton;  
> @property (weak, nonatomic) IBOutlet UITextField *myTextField;
> 
> -(IBAction)myButtonAction:(id)sender;
 
> @end  

> SWIFT  
> class MyViewController: UIViewController {  
>    @IBOutlet weak var myButton : UIButton!  
>    @IBOutlet weak var myTextField : UITextField!  
>      
>    @IBAction func myButtonAction(sender: id)  
> }

在你的故事版当中，记住要连接你的视图控制器的outlets 和 actions到相应的视图上。连接故事版中的outlets 和 actions能够确保它们在视图被加载的时候能够被正确的配置。关于如何在视图构建工具中创建outlets 和 actions的相关信息，参见“视图构建工具连接帮助指南”。关于如何处理你的应用程序中的事件的相关信息，参见“iOS事件处理指南”。

### 在运行时展示你的视图
故事版使得加载和展示你的视图控制器的视图的过程非常简单。UIKit在视图被需要的时候会自动从你的故事版当中加载视图。作为加载过程的一部分，UIKit会执行以下顺序的任务：  

1. 使用你的故事版文件中的相关信息初始化视图。
2. 连接所有的outlets 和 actions。
3. 将根视图赋值给视图控制器的view属性。
4. 调用视图控制器的awakeFromNib方法。当该方法被调用的时候，视图控制器的特征集合为空，并且它的视图很可能不在最终的位置上。
5. 调用视图控制器的viewDidLoad方法。使用该方法来添加或移除视图，修改布局约束以及为你的视图加载数据。

在显示一个视图控制器的视图到屏幕之前，UIKit给予了你一些额外的时机来准备这些视图显示到屏幕之前或之后。UIKit会以以下顺序执行任务：  

1. 调用视图控制器的 viewWillAppear: 方法让视图控制器知道它的视图将要被显示在屏幕上了。
2. 更新视图的布局。
3. 展示屏幕上的视图。
4. 当视图展示在屏幕上时，调用 viewDidAppear: 方法。

当你添加，删除或者修改视图的尺寸或者位置时，要记得添加和删除任何应用在视图上的约束。对视图层次结构进行与版式相关的更改会导致 UIKit 将版式标记为待更新。在下一个更新循环中，布局引擎会使用当前的布局约束计算视图的尺寸和位置并将这些变更加载到视图层次结构上。  
关于如何不通过故事版来创建视图，参见“UIViewController 类参考”中的视图管理相关信息。
### 管理视图布局
当视图的尺寸和位置改变的时候，UIKit会为你的视图层次结构更新布局相关的信息。对于使用自动布局配置的视图来说，UIKit的自动布局引擎会使用它来根据当前的约束更新布局。UIKit还会让其他相关的对象，比如正在展示的视图控制器，知晓布局的变更，以便作出相应的反应。  
在布局的过程中，UIKit会在几个节点通知你，你可以在这几个节点中执行与布局相关的额外的任务。使用这几个通知来修改你的布局约束，或者在布局约束已经被应用后做最终的布局调整。在布局的过程中，UIKit会对每个受影响的视图控制器执行以下操作：  

1. 根据需要更新视图控制器和它的视图的特征集合；参见“特性和尺寸变更合适发生？”
2. 调用视图控制器的 viewWillLayoutSubviews 方法。
3. 对当前的 UIPresentationController 对象调用 containerViewWillLayoutSubviews 方法。
4. 调用视图控制器根视图的 layoutSubviews 方法。该方法的默认实现会使用当前可用的约束来计算新的布局信息。该方法是贯穿视图层级结构的，它会调用每个子视图的layoutSubviews方法。
5. 将计算好的布局信息应用到视图上。
6. 调用视图控制器的 viewDidLayoutSubviews 方法。
7. 调用当前 UIPresentationController 对象的 containerViewDidLayoutSubviews 方法。

视图控制器可以使用viewWillLayoutSubviews 和 viewDidLayoutSubviews方法来执行额外的更新操作来影响布局过程。在布局之前，你可能需要添加或移除视图，更新视图的尺寸和位置，更新约束或更新其他与视图相关的属性。在布局之后，你可能会需要重新加载列表数据，更新其他视图的内容，或者为视图的尺寸和位置做出最终的调整。  
以下是几条高效的管理你的布局的建议：  

* 使用自动布局。你使用自动布局创建的约束可以灵活且容易适配你的内容到不同的屏幕尺寸上。
* 利用顶部和底部的布局建议。将内容放置在这些布局建议中将确保始终可见。顶部的布局元素存在在状态栏和导航栏的高度当中。同样的，底部的布局元素存在在页签栏和工具栏的高度中。
* 在添加或移除视图的时候记得要更新约束。如果你要自动的添加或删除视图，记得要更新相关的约束。
* 当你的视图控制器的视图在动画过程中移除临时约束。当一个视图在使用UIKit的核心动画时，应当在动画过程中移除你的约束并且在动画结束的时候添加回去。当你的视图的尺寸或位置在动画过程中发生改变的时候，要记得更新你的约束。

更多关于展示视图控制器和它们在视图控制器架构中所扮演的角色的相关信息，参见“展示和转场过程”。

### 高效的管理内存
虽然分配内存的大多数情况都是由你来决定，列表4-1列出了UIViewController中你最可能分配或释放内存的相关方法。大部分的释放操作都包含移除对象的强引用。为移除一个对象的强引用，应将该对象的属性和变量指针设置为nil。

列表4-1 分配和销毁内存的位置  

任务  | 方法  | 讨论 
------------- | -------------  | -------------
分配你的视图控制器所需的关键数据结构  | 初始化方法 | 您的自定义初始化方法 (无论它是名为 init 还是其他名字) 总是负责将视图控制器对象置于已知良好的状态。使用这些方法来分配需要的任何数据结构, 以确保正确的操作。
分配或加载需要显示在你的视图上的数据  | viewDidLoad | 使用viewDidLoad方法来加载你需要展示的数据。在调用此方法时，您的视图对象将被保证存在并处于已知的良好状态。
对于低内存通知做出反应  | didReceiveMemoryWarning | 使用该方法来释放所有与你的视图控制器相关的非必要的对象。尽可能多的释放更多的内存。
释放你的视图控制器所需的关键数据结构  | dealloc | 重写该方法，在当中执行最后时刻清理你的视图控制器类的相关内容。系统自动释放存储在实例变量和你的类的属性中的对象，所以你无需显式的释放这些对象。

## 实现一个容器视图控制器
容器视图控制器是一种从不同的视图控制器当中抽取内容到一个单一的用户界面的方式。容器视图控制器通常被用作简化导航和基于已有的内容创建新的用户界面。UIKit中的容器视图控制器的例子包括UINavigationController，UITabBarController，和 UISplitViewController，所有的这些都是优化你的用户界面的不同部分之间的导航的。
### 设计一个自定义的容器视图控制器
一个容器视图控制器在管理根视图和相关内容的时候是与内容类视图控制器几乎相同的。区别是容器视图控制器是从其他的视图控制器获取内容的。它获取的内容限于其他视图控制器的视图，视图是嵌入在视图控制器本身的视图层级中的。容器视图控制器会为任何嵌入的视图设置尺寸和位置，但原视图控制器仍旧管理着这些视图中的内容。  
当设计你自己的容器视图控制器的时候，要理解容器和被装载的视图控制器之间的联系。视图控制器之间的联系能够帮你知晓如何显示内容到屏幕上，以及如何在容器内部管理它们。在设计期间，要问问你自己以下的问题：  

* 容器所扮演的角色是什么，它的子控制器所扮演的角色是什么？
* 需要同时展示多少子视图？
* （如果不止一个子视图控制器的话）子视图控制器之间的关系是什么？
* 子视图控制器如何从容器中被添加或移除？
* 子视图控制器的尺寸和位置能够改变么？在什么情况下，这些改变会发生？
* 容器是否提供自己的任何装饰或与导航相关的视图？
* 容器和子视图控制器之间需要什么样的交流方式？是容器要通知特定的事件给它的子视图控制器还是通过UIViewController 类定义的标准函数？
* 容器的展示可以被配置成不同的方式么？如果可以的话，怎么做？

在你定义好了不同对象的角色之后，要实现一个容器视图控制器所要做的就很简单了。UIKit只要求你要在容器视图控制器和任何子视图控制器之间建立一个正式的父子关系。父子关系会确保孩子会收到任何系统相关的消息。除此之外，对于每个不同的容器而言，大部分真实的工作会发生在布局和管理孩子视图的过程中。你可以将视图放置在你的容器的任意位置，设置任何你想要的尺寸。你还可以添加自定义视图到视图层级中来提供装饰效果，或者辅助导航。
#### 示例：导航控制器
一个 UINavigationController 对象通过层级数据来支持导航。一个导航界面一次只展示一个子视图控制器。在界面的顶部会展示一个导航栏，它表示当前数据层级当中的位置，还会展示一个返回按钮用来返回上一层。向下一层级的导航交给子视图控制器，也可以由列表或按钮来实现。  
视图控制器之间的导航由导航控制器和它的孩子共同管理。当用户点击子视图控制器当中的一个按钮或者列表的一行时，子视图控制器会告诉导航控制器要将一个新的视图控制器压入当前视图。子视图控制器会处理新视图控制器的内容的相关配置，但导航控制器管理着转场动画。导航控制器还管理着导航栏，它有一个返回按钮，用来移除最上层的视图控制器。  
图5-1展示了导航控制器和它的视图之间的结构。大部分区域都被最上层的子视图控制器所填充，只有一小部分区域被导航栏所占据。  

图5-1 导航界面的结构
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_structure-of-navigation-interface_5-1_2x.png)  

无论什么环境下，一个导航控制器只会一次展示一个子视图控制器。导航控制器会调整它的子视图控制器来适应合适的位置。
#### 示例：分栏视图控制器
一个 UISplitViewController 对象会以主－从的方式来展示两个视图控制器的内容。在这种方式下，主视图控制器的内容决定了由另一个视图控制器展示的内容。两个视图控制器的展示区域是可配置的，但也受当前的环境影响。在比较宽松的区域下，分栏视图控制器能够并排展示两个子视图控制器或者根据需要隐藏主视图控制器。在比较紧凑的区域下，分栏视图控制器一次只能展示一个视图控制器。  
图5－2展示了分栏视图的界面结构以及它的视图在比较宽松的区域下的样子。分栏视图控制器在默认情况下只拥有它的容器本身。在这个例子当中，两个子视图控制器是并排展示的。两个子视图的大小是可配置的，这与主视图的大小一样。  

图5-2 一个分栏视图界面  
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG-split-view-inerface_5-2_2x.png)

### 在IB中配置一个容器
在设计时创建一个父子关系的容器，需要将一个容器视图对象添加到你的故事版场景中，如图5-3所示。一个容器视图对象是一个占位符对象，它代表了一个子视图控制器的内容。使用该视图可以调整和定位子级的根视图, 使其与容器中的其他视图相对应。  

图5-3 添加一个容器视图到界面编辑器当中  
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/container_view_embed_2x.png)

当你加载的视图控制器拥有一个或多个容器视图的时候，界面编辑器同样会加载与这些视图相关的子视图控制器。子视图控制器必须与父视图同一时间被初始化，以便在创建的时候就能够形成相应的父子关系。  
如果你不使用界面编辑器来设置你的父子容器关系的话，你必须通过代码的方式添加每个子控制器到你的容器视图控制器当中来创建这种关系，这在“添加一个子视图控制器到你的内容中”中有相关描述。
### 实现一个自定义的容器视图控制器
要实现一个容器视图控制器，你必须在你的视图控制器和它的子视图控制器之间建立联系。在你试图管理任何子视图控制器的视图之前你就应该建立这种父子关系。这样做能够让UIKit知道你的视图控制器在管理着子视图控制器的位置和大小。你可以通过界面编辑器或者编码的方式来创建这种关系，当你通过编码的方式创建父子关系的时候，你应当将显式的添加和移除视图控制器作为你的视图控制器设置的一部分。
#### 添加一个子视图控制器到你的内容中
如果要通过编码的方式包含一个子视图控制器到你的内容当中，需要在相关的视图控制器之间通过以下方式创建父子关系：  

* 调用容器视图控制器的 addChildViewController: 方法。该方法会告诉UIKit你的容器视图控制器现在已经接管了子视图控制器的视图。
* 添加子视图控制器的根视图到你的容器视图层级当中。永远要记得在这个过程中要设置子视图的大小和位置。
* 为子视图控制器的根视图添加约束来管理大小和位置。
* 调用子视图控制器的 didMoveToParentViewController: 方法。

清单5-1展示了一个容器如何将一个子视图控制器嵌入的过程。在创建了父子关系之后，一个容器要设置子视图的尺寸，并将子视图添加到它自己的视图层级当中。设置子视图的尺寸是非常重要的，这将确保视图能够在容器当中正确的展示出来。在添加视图之后，容器调用子视图的didMoveToParentViewController: 方法，来让子视图控制器有机会在它自己的视图当中来对视图进行调整。  

清单5-1 添加一个子视图控制器到容器中  
> -(void) displayContentController: (UIViewController*) content {  
	   [self addChildViewController:content];  
	   content.view.frame = [self frameForContentController];  
	   [self.view addSubview:self.currentClientView];  
	   [content didMoveToParentViewController:self];  
> }  

在这个例子当中，要注意，你只调用了子视图控制器的didMoveToParentViewController: 方法。这是因为addChildViewController: 方法为你调用了子视图控制器的willMoveToParentViewController: 方法。你必须要手动调用didMoveToParentViewController: 方法的原因是在你将子视图控制器的视图嵌入到你的容器视图层级之后，你就没有机会再调用该方法了。  
当使用自动布局的时候，要在讲子视图添加到容器视图层级之后设置容器视图和子视图之间的约束。你的约束应该只影响子视图控制器的根视图的大小和位置。不要改变根视图的内容或者任何子视图层级当中的其它视图。
#### 移除一个子视图控制器
要想将一个子视图控制器从你的容器当中移除，要通过以下几点来解除视图控制器之间的父子关系：  

* 调用子视图控制器的 willMoveToParentViewController: 方法，将值设置为nil。
* 移除你为子视图控制器配置的相关约束。
* 从你的视图层级当中移除子视图控制的根视图。
* 调用子视图控制器的 removeFromParentViewController 方法，这将终止父子关系。

移除一个子视图控制器将永久的隔断父子视图控制器之间的关系。你应该在不再需要一个子视图控制器的时机再移除它。举例来说，一个导航视图控制器不应当在当前的子视图控制器被创建并压入栈中的时候移除它。而仅应当在它移出栈的时候移除它。  
清单5-2为你展示了如何从容器当中移除一个子视图控制器。调用willMoveToParentViewController: 方法并设置为nil给了子视图控制器机会来响应准备被移除的过程。removeFromParentViewController方法同样会调用调用子视图控制器的didMoveToParentViewController: 方法，并传递给该方法nil值。设置父视图控制器为nil，最终从你的容器中解除了子视图控制器。  

清单5-2 从容器中移除子视图控制器  
> -(void) hideContentController: (UIViewController*) content {  
  		[content willMoveToParentViewController:nil];  
	   [content.view removeFromSuperview];  
	   [content removeFromParentViewController];  
>  }

#### 子视图控制器之间的转换
当你想要以动画的方式用一个子视图控制器替换另一个的话，要在转场动画过程中包括添加和移除子视图控制器两个操作。在动画开始之前，要确保两个子视图控制器都是你的容器视图控制器内容的一部分，但要让当前的子视图控制器知道它要被移除掉了。在动画过程中，将新的子视图控制器的视图移动到相应的位置，将旧的子视图控制器的视图移开。在动画完成后，要完成子视图控制器的移除操作。  
清单5-3 展示了如何使用动画的方式来将两个子视图控制器进行替换的示例。在这个例子当中，新的视图控制器被以动画的方式移动到已经存在的子视图控制器的矩形区域，后者将被移出屏幕。在动画完成后，在完成代码块中从容器中移除了子视图控制器。在这个例子当中，transitionFromViewController:toViewController:duration:options:animations:completion: 方法自动更新了容器的视图层级，所以你无需添加和删除视图。  

清单5-3 两个子视图控制器之间的转换  
	
		- (void)cycleFromViewController: (UIViewController*) oldVC
               toViewController: (UIViewController*) newVC {
	   // Prepare the two view controllers for the change.
	   [oldVC willMoveToParentViewController:nil];
	   [self addChildViewController:newVC];
 		
	   // Get the start frame of the new view controller and the end frame
	   // for the old view controller. Both rectangles are offscreen.
	   newVC.view.frame = [self newViewStartFrame];
	   CGRect endFrame = [self oldViewEndFrame];
 
	   // Queue up the transition animation.
	   [self transitionFromViewController: oldVC toViewController: newVC
        duration: 0.25 options:0
        animations:^{
            // Animate the views to their final positions.
            newVC.view.frame = oldVC.view.frame;
            oldVC.view.frame = endFrame;
        }
        completion:^(BOOL finished) {
           // Remove the old view controller and send the final
           // notification to the new view controller.
           [oldVC removeFromParentViewController];
           [newVC didMoveToParentViewController:self];
        }];
	}

#### 为子视图控制器管理显示更新
在添加一个子控制器到容器中后，容器会自动的向前发送显示相关的信息给子控制器。这通常是符合你想要的行为，因为这确保了所有的事件都被适当的发送。然而，有些时候的默认行为的的发送顺序可能不太符合你的容器所需。举例来说，如果多个子控制器同时改变它们视图的状态，你可能需要合并这些改变以便显示的回调以一种更符合逻辑的顺序在同一时间发生。  
为处理显示的回调，在你的容器中重写shouldAutomaticallyForwardAppearanceMethods 方法并且返回NO，就像清单5-4那样。返回NO会让UIKit知道你的容器视图控制器通知它的子控制器的显示变更了。  

清单5-4 禁止向前自动显示  

		- (BOOL) shouldAutomaticallyForwardAppearanceMethods {
		    return NO;
		}

当显示的转换发生的时候，视情况调用子控制器的方法 beginAppearanceTransition:animated: 或 endAppearanceTransition 方法。举例来说，如果你的容器只有一个子控制器，它被child属性所持有，你的容器应当向前发送这些消息给你的子控制器，见清单5-5所展示的。  

清单5-5 当容器出现或消失的时候，向前发送展示的信息  

		-(void) viewWillAppear:(BOOL)animated {
		    [self.child beginAppearanceTransition: YES animated: animated];
		}
 
		-(void) viewDidAppear:(BOOL)animated {
		    [self.child endAppearanceTransition];
		}
		 
		-(void) viewWillDisappear:(BOOL)animated {
		    [self.child beginAppearanceTransition: NO animated: animated];
		}
 
		-(void) viewDidDisappear:(BOOL)animated {
		    [self.child endAppearanceTransition];
		}

### 构建一个容器视图控制器的一些建议
设计，开发和测试一个新的容器视图控制器会花费很多时间。尽管单一的视图控制器的行为很简单，但控制器如果作为一个整体的话，会很复杂。请在设计实现你自己的容器类的时候考虑以下建议：  

* 仅访问子视图控制器的根视图。一个容器应当仅访问每个子控制器的根视图——这指的是子视图控制器的view属性所返回的视图。它永远不应当访问子视图控制器的其它视图。
* 子视图控制器应当尽可能少的了解其容器视图控制器。子视图控制器应当关注于它自己本身的内容。如果容器视图控制器允许其内行为被一个子视图控制器所影响的话，它应当使用代理设计模式来管理这些交互。
* 应当先使用较规则的视图来设计你的容器。使用较规则的视图（而不是子视图控制器的视图）将让你能够在一个比较简单的环境中测试布局约束和转场动画。当较规则的视图如你想象般运行的话，再将其替换为你的子视图控制器的视图。

### 一个子视图控制器的代理控制
容器视图控制器可以将其自身外观的某些方面委派给一个或多个其子视图控制器。你可以以代理的方式控制以下方面：  

* 让一个子视图控制器决定状态栏的样式。为了能够以代理来控制子视图控制器状态栏的显示，你需要在你的容器视图控制器当中重写一个或者全部方法：childViewControllerForStatusBarStyle 和 childViewControllerForStatusBarHidden。
* 让子视图控制器决定它的优先尺寸。以弹性布局的容器可以使用子视图控制器的preferredContentSize 属性来帮助子视图控制器决定它的尺寸。

## 支持辅助功能

### 将辅助语音提示指针移动到指定的元素

### 响应特定的辅助语音提示的手势

#### 移开

#### 魔法点击

#### 三指滚动

#### 增加和减少

### 监听辅助功能的通知

## 保存和恢复状态
在保存和回复状态的过程中，视图控制器扮演了一个非常重要的角色。状态的保存在你的应用程序被挂起之前记录了你的它的配置，所以它能够在应用程序随后被加载的时候恢复配置。返回一个已经配置好的应用程序会为用户节省时间，并且这也为用户提供了良好体验。  
保存和恢复过程基本是自动的，但你要让iOS知道你的应用程序的哪部分要被保存。保存你的应用程序的视图控制器的步骤如下：  

* (必须)给你想要恢复的视图控制器赋值恢复ID；参见“为保存的视图控制器进行标记”。
* (必须)告诉iOS如何在加载时创建或者定位新的视图控制器对象；参见“在加载时恢复一个视图控制器”。
* (可选)对于每个视图控制器，保存返回时指定的配置数据需要视图控制器自己进行配置；参见“编解码你的视图控制器的状态”。

关于保存和恢复过程的概述，参见“iOS应用程序编程指南”。
### 为保存的视图控制器进行标记
UIKit只在你告诉它要保存视图控制器时才进行保存。每个视图控制器都有个restorationIdentifier 属性，该属性默认为nil。设置该属性为一个有效的字符串会告诉UIKit该视图控制器以及它的视图需要被保存。你可以以编码的方式或者故事版文件的方式来赋值恢复ID。  
当赋值恢复ID的时候，要记得它所有的在视图控制器层级中的父视图控制器也被赋值恢复ID。在恢复过程中，UIKit先从窗口的根视图控制器开始，然后遍历视图控制器层级。如果在该层级当中一个视图控制器没有一个恢复ID的话，该视图控制器以及它所有的子视图控制器和保存的视图控制器都会被忽略。
#### 选择有效的恢复ID
UIKit会使用你的恢复ID来在随后重新创建视图控制器，所以你应当选择容易识别的ID作为这个字符串。如果UIKit不能够自动创建你的视图控制器的话，它会要求你来创建它，提供给你视图控制器的恢复ID和所有它的父视图控制器。这个ID链条表示视图控制器的恢复路径以及你决定哪个视图控制器是被需要的。恢复路径从根视图控制器开始包含每个视图控制器，直到包含那个被需要的视图控制器。  
恢复ID通常使用视图控制器的类名。如果你在很多地方使用同样的类的话，你可能需要赋值更有区分性的值了。举例来说，你可能会赋值一个基于视图控制器管理的数据的字符串。  
每个视图控制器的恢复路径必须唯一。如果一个容器视图控制器有两个子视图控制器的话，容器视图控制器必须给每个子视图控制器赋予一个唯一的恢复ID。在UIKit中的有些容器视图控制器会自动的销毁它的子视图控制器，这允许你为每个子视图控制器使用同样的恢复ID。举例来说，UINavigationController 类会为每个子视图控制器基于它在栈中的位置添加相关信息。关于给定的视图控制器的行为的相关信息，参见相关的类引用文件。  
关于你如何使用恢复ID和恢复路径来创建视图控制器的相关信息，参见“在启动时恢复一个视图控制器”。
#### 排除一组视图控制器
如果想从恢复过程中排除一组视图控制器的话，设置该组视图控制器的父视图控制的恢复ID为nil即可。图7-1展示了设置恢复ID为nil之后在视图层级中的影响。缺少保存数据会使视图控制器以后无法恢复。  

图7-1 从自动保存过程中排除一组视图控制器   

![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/state_vc_caveats_2x.png)  

排除一个或多个视图控制器不会将它们从随后的恢复中移除。在启动过程中，任何你的应用程序的视图控制器都还会被创建，如图7-2所示。即使是那些以默认配置重新创建的视图控制器也依旧是被创建的。  

图7-2 加载默认的一组视图控制器  

![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/state_vc_caveats_2_2x.png)  

从自动恢复过程中排除一组视图控制器不会影响你手动的恢复它们。在恢复归档中持有一个视图控制器的引用会保存该视图控制器以及它的相关状态信息。举例来说，如果在图7-1中的应用程序代理方法保存了导航视图控制器的三个子视图控制器的话，它们的状态也会被保存。在恢复过程中，应用程序的代理方法会重新创建这些视图控制器并将它们压入导航控制器的栈中。
#### 保存一个视图控制器的视图
有些视图拥有视图相关信息但与其父视图控制器无关。举例来说，一个滚动视图可能会有一个你想要保存的滚动到的位置。当视图控制器负责提供滚动视图的内容时，滚动视图本身应当负责保存其可见区域的状态。  
为保存一个视图的状态，应当做到以下几点：  

* 将一个合法的字符串赋值给视图的 restorationIdentifier 属性。
* 使用一个拥有合法恢复ID的视图控制器的视图。
* 对于表格和表单视图而言，应当将其数据源采用 UIDataSourceModelAssociation 协议。

将一个恢复ID赋值给一个视图会告诉UIKit它应当将该视图的状态保存归档。当视图控制器被随后恢复的时候，UIKit同样会恢复那些拥有恢复ID的视图的状态。
### 在启动时恢复一个视图控制器
在启动时，UIKit会视图恢复你的应用程序之前的状态。在这个时候，UIKit会要求你的应用程序创建（或定位）包含你之前保存的用户界面的视图控制器对象。当UIKit视图定位视图控制器的时候，它将以以下顺序进行检索：  

1. 如果视图控制器拥有恢复类的话，UIKit要求该类提供视图控制器。UIKit会调用相关恢复类的 viewControllerWithRestorationIdentifierPath:coder: 方法来检索视图控制器。如果该方法返回nil，那么UIKit会假定应用程序不想重新创建该视图控制器然后停止查找。
2. 如果视图控制器没有恢复类，UIKit要求应用程序的代理提供视图控制器。UIKit会调用应用程序代理类的 application:viewControllerWithRestorationIdentifierPath:coder: 方法来查找一个没有恢复类的视图控制器。若该方法返回nil，UIKit会隐式的对视图控制器进行查找。
3. 如果一个视图控制器拥有正确的恢复路径，UIKit会使用该对象。如果你的应用程序在启动时创建了视图控制器（不管是编码方式还是从一个故事版加载的）那么这些视图控制器都拥有恢复ID，UIKit会隐式的基于恢复路径对它们进行检索。
4. 如果视图控制器最初是由一个故事版文件加载的，UIKit会使用保存的故事版的相关信息来定位和创建视图控制器。UIKit会将视图控制器的故事版的相关信息保存到恢复归档当中。在恢复期间，UIKit会使用该信息来定位到相同的故事版文件然后实例化相关的视图控制器（若该视图控制器没有被其它手段查找到的话）。

将一个恢复类赋值给一个视图控制器会阻止UIKit隐式的检索该视图控制器。使用恢复类会在你真的要创建一个视图控制器的时候给你更多的控制权。举例来说，如果你的类决定该控制器不应该被重新创建，那么你的viewControllerWithRestorationIdentifierPath:coder: 方法可以返回nil。当没有恢复类被展示的时候，UIKit会尽可能的寻找或创建视图控制器并保存它。  
当使用恢复类的时候，你的viewControllerWithRestorationIdentifierPath:coder: 方法应当创建一个该类的实例对象，执行最小化的初始化，然后将处理后的对象返回。清单7-1展示了如何从一个故事版当中使用该方法来加载视图控制器的示例。由于视图控制器最初是从故事版加载的，该方法使用UIStateRestorationViewControllerStoryboardKey 为key来从归档当中回去故事版。要注意该方法并没有视图配置视图控制器的相关数据。当视图控制器的状态被解码之后才会发生该步骤。  

清单7-1 在恢复期间创建一个新的视图控制器  

		+ (UIViewController*) viewControllerWithRestorationIdentifierPath:(NSArray *)identifierComponents
                      coder:(NSCoder *)coder {
	   MyViewController* vc;
	   UIStoryboard* sb = [coder decodeObjectForKey:UIStateRestorationViewControllerStoryboardKey];
	   if (sb) {
	      vc = (PushViewController*)[sb 	instantiateViewControllerWithIdentifier:@"MyViewController"];
	      vc.restorationIdentifier = [identifierComponents lastObject];
	      vc.restorationClass = [MyViewController class];
	   }
	    return vc;
	}

当手动重新创建一个视图控制器的时候，重新赋值恢复ID和恢复类是一个应当养成的好习惯。还原恢复ID最简单的方法是从identifierComponents数组中获取最后一个元素然后将其赋值给你的视图控制器。  
对于启动时从你的应用程序主故事版中创建的对象而言，不要为每个对象创建新的实例对象。应该让UIKit隐式的查找这些对象或者使用你的应用程序的代理的 application:viewControllerWithRestorationIdentifierPath:coder: 方法来找到这些已经存在的对象。
### 编解码你的视图控制器的状态
对于每个要被保存的对象而言，UIKit会调用对象的 encodeRestorableStateWithCoder: 方法来给予对象一个时机来保存它的状态。在恢复过程中，UIKit会调用相应的 decodeRestorableStateWithCoder: 方法来解码该状态并将其应用到对象上。这两个方法是可选的，但我们推荐你在你的视图控制器中实现它。在以下几个方面你可能会用它们来保存和恢复某些状态信息：  

* 任何有关要被展示的数据（不是数据本身）
* 对于容器视图控制器而言，有关它的子视图控制器的相关信息。
* 有关当前选中的信息
* 对于视图控制器中有用户可配置的视图而言，可存储该视图的当前配置信息。

在你的编解码方法当中，你可以编码任何coder支持的对象和数据类型。除了视图和视图控制器之外的所有对象都必须采用NSCoding协议并应使用相应协议方法来编写它的状态。对于视图和视图控制器而言，coder 不会使用NSCoding协议来保存该对象的状态。取而代之的是，coder会保存该对象的恢复ID，将其添加到保存对象列表当中，后者将会调用对象的encodeRestorableStateWithCoder:方法。  
你的视图控制器的encodeRestorableStateWithCoder: 和 decodeRestorableStateWithCoder:方法在实现的时候必须在某个时间点调用super。调用super会给父类一个机会来保存和恢复一些额外的信息。清单7-2展示了这两个方法的实现示例，在这个例子中使用了一个数字值来标识指定的视图控制器。  

清单7-2 编解码一个视图控制器的状态

		- (void)encodeRestorableStateWithCoder:(NSCoder *)coder {
		   [super encodeRestorableStateWithCoder:coder];
 
		   [coder encodeInt:self.number forKey:MyViewControllerNumber];
		}
 
		- (void)decodeRestorableStateWithCoder:(NSCoder *)coder {
		   [super decodeRestorableStateWithCoder:coder];
	   		self.number = [coder decodeIntForKey:MyViewControllerNumber];
		}

Coder对象在编解码过程中并不是共享的。每个拥有保存状态的对象都会接收它自己的Coder对象。使用唯一的Coder意味着你无需担心你所使用的key与命名之间的冲突。不过，请不要使用UIApplicationStateRestorationBundleVersionKey，UIApplicationStateRestorationUserInterfaceIdiomKey，和 UIStateRestorationViewControllerStoryboardKey 等key值。这些key都是被UIKit用来保存你的视图控制器的状态信息的。  
有关实现视图控制器中编解码方法的额外信息，参见“视图控制器类参考文献”。
### 一些保存和存储你的视图控制器的建议
在你决定在你的视图控制器中支持状态的保存和恢复之后，请考虑以下的建议：  

* 要记住你并非需要保存所有的视图控制器。在某些情况下，保存一个视图控制器是没有必要的。举例来说，如果应用程序展示了一个更改，你可能想要取消操作然后将应用程序恢复到上一个屏幕内容。在这种情况下，你就不需要保存需要填写新的密码信息的那个视图控制器了。
* 避免在恢复过程中交换视图控制器类。状态保存系统将视图控制器的类进行编码保存。在恢复期间，如果你的应用程序返回一个与原对象的类不匹配的对象（或者不是它的子类），那么系统不会让视图控制器来解码任何状态信息。此外，将旧的视图控制器替换为一个完全的不同的视图控制器将不会恢复该对象的全部信息。
* 状态保存系统希望你正确的使用视图控制器。恢复过程依赖于你的视图控制器之间的包含关系来重新构建你的界面。如果你使用容器视图控制器不当的话，保存系统将不能够查找到你的视图控制器。举例来说，永远不要将一个视图控制器的视图嵌入到一个不同的视图当中，除非它是与当前视图控制器是包含的关系。

# 展示和转换
## 展示一个视图控制器

### 展示和转换过程

#### 展示样式

##### 全屏展示样式

##### 弹出样式

##### 聚焦样式

##### 自定义展示样式

#### 转换样式

#### 展示对比显示一个视图控制器

### 展示一个视图控制器

#### 显示视图控制器

#### 形式化展现视图控制器

#### 在弹出框中展示一个视图控制器

### 隐藏一个展示的视图控制器

### 展示一个在不同的故事版中定义的视图控制器

## 使用Segues

### 在视图控制器之间创建Segue

### 在运行时修改一个Segue的行为

### 创建一个展开的Segue

### 用程序初始化一个Segue

### 创建一个自定义的Segue

#### 一个Segue的生命周期

#### 实现一个自定义的Segue

## 自定义转场动画

### 转场动画的顺序

#### 转场代理事件

#### 自定义动画顺序

#### 转场上下文对象

#### 转场的协调者

### 使用自定义动画展示一个视图控制器

### 实现转场代理方法

### 实现你的动画对象

#### 获取动画参数

#### 创建转场动画

#### 在动画结束后进行清理

### 为你的转场动画添加交互

### 在转场旁边创建动画

### 使用你的动画来展现一个展示控制器

## 创建自定义展示

### 自定义展现的过程

### 创建一个自定义展示的控制器

#### 设置一个展示的视图控制器的大小

#### 管理和加载自定义视图的动画

### 交出你的展示视图的控制权给UIKit

### 适配不同尺寸的类

# 自适应性和大小的变化

## 自适应模型

### 特性的作用

### 什么时候特性和尺寸变更会发生？

### 不同的机型会有默认的控制尺寸的类

## 构建和适配界面

### 适应特性的改变

#### 配置你的故事版来处理不同的尺寸类

#### 改变一个子视图控制器的特性

#### 适配一个呈现的视图控制器为一个新的样式

#### 实现适配窗口的一些建议

### 响应尺寸变更 