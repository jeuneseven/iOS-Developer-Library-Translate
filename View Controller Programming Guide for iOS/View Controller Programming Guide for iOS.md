[View Controller Programming Guide for iOS 原文链接](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)

# 概览
## 视图控制器所扮演的角色
视图控制器是你的应用程序内部架构的基础。每个应用程序都至少含有一个视图控制器，大部分应用程序都有很多个。每个应用程序都会管理着一份你的应用程序的用户界面以及该用户界面与底层数据的交互。视图控制器同样也会改善不同的视图界面之间转换的过渡。  
由于它在你的应用程序当中扮演着如此重要的角色，视图控制器几乎会成为你做任何事的中心。UIViewController类定义了很多方法和属性来管理你的视图，处理事件，从一个视图控制器过渡到另一个以及协调你的应用程序的其他部分。你可以继承UIViewController（或者集成它的子类）然后添加自己需要实现的行为的代码即可。  
一共有两种类型的视图控制器：  

* 内容类的视图控制器管理着你的应用程序的分散的内容，它是你主要创建的视图控制器。
* 容器类视图控制器从其他的视图控制器收集信息（被称作子视图控制器）以一种简便的导航方式展示出来或者以不同的模态方式展示这些视图控制器的内容。

大部分应用程序是这两种类型视图控制器的混合体。
### 视图的管理
一个视图控制器的最重要的角色是管理视图的层级。每个视图控制器都拥有一个根视图，它将所有的视图控制器的内容都封装进去。通过这个根视图，你可以添加你需要展示的视图内容。图1-1展示了视图控制器和它的视图之间的内部关系。视图控制器将一直持有根视图，并且每个视图对于它的子视图都是强引用。  

图1-1 视图控制器和它的视图之间的关系  

![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_ControllerHierarchy_fig_1-1_2x.png)

	注意：通常使用outlets来访问在你的视图控制器层级当中的其它视图。由于一个视图控制器管理着所有它的视图的内容，outlets能够让你持有你需要的视图的引用。outlets本身在视图被从故事版加载的时候自动连接到了实际的视图对象。  

内容类的视图控制器通过它本身来管理所有的视图。容器类的视图控制器管理它本身的视图以及一个或多个子视图的根视图。容器类本身不会管理它的子视图的内容。它仅仅管理根视图，尺寸并根据容器的设计来布局。图1-2展示了一个split视图控制器以及它的子视图之间的关系。split视图控制器管理了它的子视图的总体尺寸和位置，但是子视图控制器管理了这些视图的实际内容。

图1-2 视图控制器能够管理其它视图控制器的内容

![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_ContainerViewController_fig_1-2_2x.png)  

更多关于管理你的视图控制器视图的相关信息，参见“管理视图布局”。

### 数据的封装
一个视图控制器在它管理的视图和你的应用程序的数据之间起到了一个调度的作用。UIViewController类的方法和属性能够让你管理你的应用程序的可视化部分。当你继承UIViewController类的时候，你可以添加任何你需要管理你的数据的变量到你的子类当中。添加一个自定义的变量回创建一个类似于图1-3当中的关系，当视图控制器持有你的数据，视图将会用它来展示那个数据。将数据从两者之间进行传递是你的责任。  

图1-3 一个视图控制器在数据对象和视图对象之间进行调度

![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_CustomSubclasses_fig_1-3_2x.png)

你应当在你的视图控制器和数据对象之间始终维护一个清晰的责任关系。大部分确认数据结构完整性的逻辑都应该在数据对象当中实现。视图控制器可能会需要验证从视图当中输入的内容，然后将其打包成你的数据需要的格式，但是你应该确保视图控制器在管理实际数据的过程中担任尽量少的角色。  
UIDocument对象是一种能够让数据与你的视图控制器分离的管理方式。文档对象是一个控制器对象，它知道如何永久存储一个可读写的数据。当你继承它时，你可以添加任何你需要的逻辑和方法来处理数据，你可以将其传递到一个视图控制器或者你的应用程序的其他部分。视图控制器可能会保留一份它接收到的数据的拷贝，以便将其更容易的更新到视图上，不过文档本身还是拥有实际的数据。
### 用户的交互
视图控制器是响应类型的对象，并且能够处理从响应者链条中传递过来的事件。尽管它能够这么做，但是视图控制器很少直接处理触摸事件。通常，是由视图来处理它们本身的触摸事件，然后将其结果发送给一个相关的代理方法或者目标对象，通常是一个视图控制器。所以大部分在视图控制器当中的事件都是使用代理方法或者目标函数来处理的。  
更多关于在视图控制器当中实现目标函数的相关信息，参见“处理用户交互”。更多关于处理其他类型的事件的相关信息，参见“iOS事件处理指南”。
### 资源的管理
视图控制器对其视图及其创建的任何对象承担全部责任。UIViewController类会自动的处理视图管理的大部分内容。举例来说，UIKit自动处理不再需要的视图相关的资源。在你的UIViewController子类当中，你应当管理所有由你创建的对象。  
当可用的内存较少的时候，UIKit会要求应用程序释放任何不再需要的资源。其中一种方式是调用你的视图控制器当中的didReceiveMemoryWarning方法。使用该方法来移除你不再需要的对象的引用或在以后重新创建。比如，你可以使用该方法移除缓存的数据。当发生低内存警告的时候，尽你所能的释放更多的内存是很重要的。应用程序如果消耗过多的内存的话，可能会被系统完全终止来释放内存。
### 自适应性
视图控制器要负责展示它的视图，并且要适配那些展示的视图来匹配底层环境。每款iOS的应用程序都应该能够运行在iPad上以及不同尺寸的iPhone手机上。使用一个单一的视图控制器来适配它的视图来改变空间所需更为简单，而不是为不同的设备提供很多的视图控制器和视图层级。  
在iOS上，视图控制器要处理各种粗细粒度的尺寸变更。当一个视图控制器的特性发生改变的时候会有粗粒度的变更。特性是用来描述整体环境的一种属性，比如展示的缩放。视图控制器有两个非常重要的特性就是垂直方向和水平方向的尺寸控制类，它们表示视图控制器在给定的尺寸当中有多少空间能够用来展示。你可以使用尺寸类的变更来作为改变你的视图布局的方式，如图1-4所示。当水平尺寸控制类为regular（分散对齐）的时候，视图控制器会利用额外的水平空间来布局它的内容。当水平尺寸控制类为compact（紧凑对齐）的时候，视图控制器会对其内容进行垂直布局。  

图1-4 适配视图来进行尺寸类变更
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_SizeClassChanges_fig_1-4_2x.png)  

在一个给定的尺寸类当中，随时都会发生很多的细粒度的尺寸变更。当用户将iPhone从竖直方向转为水平方向，尺寸类可能不会改变，而屏幕的尺寸通常会变更。当你使用自动布局的时候，UIKit自动的调整视图的尺寸和位置来匹配新的尺寸。视图控制器可以根据需要来进行额外的调整。  
更多关于自适应性的相关信息，参见“自适应模型”。
## 视图控制器的层级结构
你的应用程序当中的视图控制器之间的关系定义了每个视图控制器所需要的行为。UIKit框架期望你以规定的方式来使用视图控制器。维持视图控制器之间适当的关系，确保在视图控制器被需要的时候能够自动调用适当的行为发送给对应的视图控制器。如果你打破了规定的包含和展示关系，你的应用程序的某些部分将会不出意外的停止某些行为。
### 根视图控制器
根视图控制器是视图控制器层级的根节点。每个窗口都拥有一个根视图控制器，它的内容会填充该窗口。根视图控制器定义了最初能够被用户所见的内容。图2-1展示了根视图控制器和窗口之前的关系。由于窗口本身没有能够展示的内容，视图控制器的视图提供了所有它的内容来展示。  

图2-1 根视图控制器
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG-root-view-controller_2-1_2x.png)  

UIWindow对象的rootViewController属性可以用来让根视图控制器访问。当你使用故事版来配置你的视图控制器的时候，UIKit会在启动的时候自动的设置这个属性的值。对于代码创建的窗口而言，你必须自己设置根视图控制器。
### 容器视图控制器
容器视图控制器使您可以从更易于管理和可重用的部分组装复杂的接口。一个容器视图控制器结合了一个或多个子视图控制器和一些自定义的视图内容来创建最终的界面。举例来说，一个UINavigationController对象展示了一个子视图控制器的内容和一个导航栏以及一个可选的工具栏，它们都是被导航控制器所管理的。UIKit包含了多种容器类的视图控制器，包括UINavigationController，UISplitViewController， 和 UIPageViewController。  
一个容器类视图控制器的视图会将给予它的空间全部填满。容器视图控制器通常在一个窗口当中作为根视图控制器（如图2-2所示），不过它们同样可以被模态展示或者作为其他容器的子视图控制器。容器负责将它的子视图布置到合适的位置。在视图当中，容器将两个子视图并排放置。尽管它依附于容器界面，子视图控制器会尽少的和容器以及并排的视图控制器关联。

图2-2 容器扮演根视图控制器的角色  
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG-container-acting-as-root-view-controller_2-2_2x.png)

由于容器视图控制器管理着它的子类，UIKit为如何在自定义容器中设置这些子类定义了规则。关于如何创建一个自定义容器视图控制器的详细信息，参见“实现一个容器视图控制器”。
### 展现视图控制器
展现一个视图控制器会用它的新的内容取代当前视图控制器的内容，通常会隐藏之前视图控制器的内容。展示的形式通常用于展现新内容模式。举例来说，你可能会展示一个视图控制器来收集用户的输入。你还可以使用它来作为你的应用程序界面的一个通用的构建模块。  
当你展现一个视图控制器的时候，UIKit会在展现的的视图控制器和被展现的视图控制器之间建立关系，如图2-3所示。(这在从被展现的视图控制器返回展现的视图控制器之间是一对相反的关系。)这种关系是组成视图控制器层级关系的一部分，同样也是在运行时定位其他视图控制器的一种方式。  

图2-3 展现视图控制器
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG-presented-view-controllers_2-3_2x.png)  

当有容器类视图控制器参与的时候，UIKit可能会修改展示链来简化你必须编写的代码。不同的展现样式会有不同的规则来决定它们如何被展示在屏幕上——举例来说，全屏的展现通常会覆盖整个屏幕。当你展现一个视图控制器的时候，UIKit会找到一个提供合适上下文的视图控制器用来展现。在大多数情况下，UIKit会选择最近的容器视图控制器，不过也可能会选择窗口的根视图控制器。在某些情况下，你还能够告诉UIKit哪个视图控制器定义了展现的上下文，并且它应该处理展现的逻辑。  
图2-4展示了为什么容器通常会为展现提供上下文。当执行全屏幕展现的时候，新的视图控制器需要覆盖整个屏幕。容器决定是否处理展现逻辑，子视图无需知道它的容器的边界。由于示例中的导航控制器涵盖整个屏幕, 因此它充当呈现视图控制器并负责初始化展现逻辑。

图2-4 一个容器和一个展现的视图控制器
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG-container-and-presented-view-controller_2-4_2x.png)  

更多关于展现的相关信息，参见“展现和转换过程”部分。
## 设计指南
视图控制器作为应用程序运行在iOS上的基本工具，UIKit对于视图控制器的基本架构使得创建复杂界面极为简单，而无需编写大量的代码。当实现你自己的视图控制器的时候，请采取以下的建议和指南以确保您不会执行可能干扰系统所期望的自然行为的操作。
### 尽量使用系统支持的视图控制器
很多iOS的框架都定义了视图控制器来让你用在你的应用程序当中。使用这些系统提供的视图控制器能够节省你的时间，并且能够为用户提供始终如一的体验。  
大部分系统的视图控制器都是为特定任务设计的。某些视图控制器提供访问用户的数据功能，比如通讯录。还有的视图控制器会提供访问硬件的功能，或者提供对于媒体管理进行相关调试的界面。比如UIKit当中的UIImagePickerController类展示了一个标准界面来拍摄照片和视频，并且可以用它来访问用户的相机胶卷。  
在你创建你自定义的视图控制器之前，最好先查看一下已有的框架当中是否存在你要执行的任务的相关视图控制器。  

* UIKit框架提供了视图控制器来展示警告框，拍摄视频和照片以及管理在iCloud上的文件。UIKit同样定义了很多容器视图控制器，你可以用来管理你的内容。
* GameKit提供了视图控制器来匹配玩家和管理排行榜，成就榜以及其它游戏相关的功能。
* Address Book UI（地址簿）框架提供了视图控制器来展示和选择通讯录相关信息。
* MediaPlayer（媒体）框架提供了视图控制器来播放和管理视频，还可以通过它来选择用户相册中的媒体数据。
* EventKit UI（日历）框架提供了视图控制器来展示和编辑用户的日历数据。
* GLKit框架提供了视图控制器来管理OpenGL渲染层。
* Multipeer Connectivity（多点连接）框架提供了视图控制器来检测其它用户的状态，并邀请连接。
* Message UI（消息）框架提供了视图控制器来编写邮件和短信息。
* PassKit框架提供了视图控制器展示护照和添加护照到护照本当中。
* Social框架提供了视图控制器来为twitter，Facebook和其它的社交媒体的发布信息进行排版。
* AVFoundation框架提供了视图控制器来展示媒体数据。
	
> 重要  
> 永远不要修改系统提供的视图控制器的视图层级。每个视图控制器都有它自己的视图层级，并且它会负责维护该层级的完整性。进行更改可能会将 bug 引入到代码中, 或阻止拥有视图控制器正常运行。在使用系统提供的视图控制器的时候，你应当一直依赖使用视图控制器提供的公共方法和属性来进行修改。

更多的使用特定的视图控制器的相关信息，参见相应的框架的相关文档。

### 尽量使每个视图控制器孤立
视图控制器应当始终是一个独立的对象。任何视图控制器都不应该知晓其它的视图控制器的内部工作以及视图结构。在两个视图控制器需要交互或者来回传递数据的情况下，它们应当使用明确定义的公共接口来做这件事。  
代理模式会在视图控制器的交互管理当中被频繁的使用。通过代理方式，一个对象会定义一个协议来与它相关的代理对象通信，任何对象都可以遵循协议。代理对象的类型的确定性并不重要。重要的是它实现了协议中的方法。
### 使用根视图的时候，将其仅作为其它视图的容器
应当使用你的视图控制器的根视图仅仅作为你的内容的容器。使用根视图作为容器会让你的视图拥有一个共用的父视图，这会让很多布局操作更为简单。很多自动布局的约束需要一个共用的父视图来对视图进行适当的布局。
### 要知晓你的数据的生命周期
在模型－视图－控制器这种设计模式当中，视图控制器所扮演的角色是促进数据在你的模型对象和你的视图对象之间移动。一个视图控制器可能会存储某些临时变量数据或者执行某些验证，但是它的主要责任是确保它的视图包含了确定的信息。你的数据对象要负责管理实际的数据，并且确保那些数据的完整性。  
一个数据与界面分离的例子是 UIDocument 和 UIViewController 类之间的关系。特别的是，没有默认的关系存在于它们两者之间。当一个UIViewController对象展示视图到屏幕上的时候，UIDocument对象负责加载和保存数据。当你在这两个对象之间建立联系的时候，要记住，视图控制器只为了效率才从document缓存信息。实际的数据依旧属于document对象。
### 要适应改变
应用程序很可能运行在各种iOS设备上，那么视图控制器也会被设计成适应不同尺寸的设备的屏幕。你可以使用你的视图控制器中内置的适配支持来响应尺寸类的变更，而无需使用不同的视图控制器来管理不同屏幕上的内容。UIKit会发送通知来给你适当的机会来放大或缩小来改变你的用户界面，而无需改变你的视图控制器当中的其它的代码。  
更多关于适配变更的相关信息，参见“适配模型”。
# 视图控制器的定义
## 定义你的子类
使用 UIViewController 的子类来展示你的应用程序的内容。大部分自定义的视图控制器都是内容视图控制器——意思是它们拥有所有相关视图和负责这些视图上的数据展示。相比之下，容器视图控制器不拥有全部的相关视图；这些视图当中的一部分被其他的视图控制器管理。定义内容类和容器类视图控制器的大部分步骤都是类似的，这会在后续章节当中进行讨论。  
对于内容视图控制器，比较通用的父类是以下几种：  

* 你的视图控制器主要是展示一个列表的时候，继承UITableViewController
* 你的视图控制器主要是展示一个表格的时候，继承UICollectionViewController
* 对于其他的视图控制器继承UIViewController

对于容器类视图控制器，父类取决于你是在修改一个已经存在的容器类还是创建你自己的。对于已经存在的容器，你可以任意选择已经存在的容器类来修改。对于你创建的新的容器视图控制器，通常继承于UIViewController。关于创建一个容器视图控制器的相关信息，参见“实现一个容器类视图控制器”。
### 定义你的UI
你可以使用Xcode的故事版来为你的视图控制器可视化的定制UI。尽管你可以使用代码的方式创建你的UI界面，但是故事版是一种非常好的方式来可视化的编辑你的视图控制器的内容，并且可以根据不同的环境定制视图层级（根据需要）。可视化的构建UI界面，能让你更快速的响应变化，让你无需构建和运行你的应用程序就能够看到结果。  
图4-1展示了一个故事版的例子。每个矩形的区域都代表了一个视图控制器以及它关联的视图。视图控制器之间的箭头代表了视图控制器的关系和转场。Relationships链接了一个容器视图控制器和它的子视图控制器。Segues让你能够在你的界面当中在视图控制器之间导航。    

图4-1 故事版处理一批视图控制器和视图
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/storyboard_bird_sightings_2x.png)  

每个新建的工程都会有一个主故事版，它通常会包含一个或多个视图控制器。你可以通过从库中拖拽一个新的视图控制器到你的故事版中达到添加的目的。新的视图控制器在创建的时候不会关联它的相关类，所以你必须使用身份匹配功能来为它赋值。  
使用故事版编辑器可以做以下功能：  

* 为视图控制器的视图添加，调整以及配置。
* 连接接口和行为；参见“处理用户交互”。
* 在视图控制器之间创建关系和转场；参见“使用Segues”。
* 为不同的尺寸类定制布局和视图；参见“构建一个适配的界面”。
* 添加手势识别来处理用户与视图之间的交互；参见“iOS事件处理指南”。

如果你是使用故事版来构建你的界面的新手，你可以在“从现在开始开发iOS应用程序”中找到创建基于故事版的界面的步骤说明。
### 处理用户的交互
一款应用程序的响应者对象会处理外来事件并给予合适的执行方法。尽管视图控制器就是响应者对象，但它们很少直接处理触摸事件。通常，视图控制器会以以下几种方式来处理事件。  

* 视图控制器会定义响应方法来处理高优先级的事件。响应方法会响应：  
	* 指定的事件。控件和其他的视图会调用响应方法来报告指定的交互。
	* 手势。手势会调用一个响应方法来报告当前的手势状态。使用你的视图控制器来处理手势的状态变更或者响应完整的手势。
* 视图控制器会监听由系统或其他对象发出的通知。通知会报告状态的变化，这是视图控制器更新状态的一种时机。
* 视图控制器会担当其他对象的数据源或者代理。视图控制器通常被用来管理列表和表单视图的数据。你还可以使用它来作为一个对象（例如 CLLocationManager 对象）的代理，后者会发送地理位置的更新数据给它的代理。  

响应事件通常包含更新视图的内容，这需要关联这些视图。你的视图控制器是定义你稍后要修改的视图的绝佳位置。使用清单4-1当中的语句来声明你的outlets作为属性。清单中的自定义类定义了两个outlets（被称作IBOutlet关键字）以及一个动作方法（被称作IBAction返回类型）。outlets存储在故事版当中，关联到了一个按钮和一个输入框，动作方法会响应按钮的点击。  

清单4-1 在视图控制器类中定义outlets和actions  

> OBJECTIVE-C  
> @interface MyViewController : UIViewController  
> @property (weak, nonatomic) IBOutlet UIButton *myButton;  
> @property (weak, nonatomic) IBOutlet UITextField *myTextField;
> 
> -(IBAction)myButtonAction:(id)sender;
 
> @end  

> SWIFT  
> class MyViewController: UIViewController {  
>    @IBOutlet weak var myButton : UIButton!  
>    @IBOutlet weak var myTextField : UITextField!  
>      
>    @IBAction func myButtonAction(sender: id)  
> }

在你的故事版当中，记住要连接你的视图控制器的outlets 和 actions到相应的视图上。连接故事版中的outlets 和 actions能够确保它们在视图被加载的时候能够被正确的配置。关于如何在视图构建工具中创建outlets 和 actions的相关信息，参见“视图构建工具连接帮助指南”。关于如何处理你的应用程序中的事件的相关信息，参见“iOS事件处理指南”。

### 在运行时展示你的视图
故事版使得加载和展示你的视图控制器的视图的过程非常简单。UIKit在视图被需要的时候会自动从你的故事版当中加载视图。作为加载过程的一部分，UIKit会执行以下顺序的任务：  

1. 使用你的故事版文件中的相关信息初始化视图。
2. 连接所有的outlets 和 actions。
3. 将根视图赋值给视图控制器的view属性。
4. 调用视图控制器的awakeFromNib方法。当该方法被调用的时候，视图控制器的特征集合为空，并且它的视图很可能不在最终的位置上。
5. 调用视图控制器的viewDidLoad方法。使用该方法来添加或移除视图，修改布局约束以及为你的视图加载数据。

在显示一个视图控制器的视图到屏幕之前，UIKit给予了你一些额外的时机来准备这些视图显示到屏幕之前或之后。UIKit会以以下顺序执行任务：  

1. 调用视图控制器的 viewWillAppear: 方法让视图控制器知道它的视图将要被显示在屏幕上了。
2. 更新视图的布局。
3. 展示屏幕上的视图。
4. 当视图展示在屏幕上时，调用 viewDidAppear: 方法。

当你添加，删除或者修改视图的尺寸或者位置时，要记得添加和删除任何应用在视图上的约束。对视图层次结构进行与版式相关的更改会导致 UIKit 将版式标记为待更新。在下一个更新循环中，布局引擎会使用当前的布局约束计算视图的尺寸和位置并将这些变更加载到视图层次结构上。  
关于如何不通过故事版来创建视图，参见“UIViewController 类参考”中的视图管理相关信息。
### 管理视图布局
当视图的尺寸和位置改变的时候，UIKit会为你的视图层次结构更新布局相关的信息。对于使用自动布局配置的视图来说，UIKit的自动布局引擎会使用它来根据当前的约束更新布局。UIKit还会让其他相关的对象，比如正在展示的视图控制器，知晓布局的变更，以便作出相应的反应。  
在布局的过程中，UIKit会在几个节点通知你，你可以在这几个节点中执行与布局相关的额外的任务。使用这几个通知来修改你的布局约束，或者在布局约束已经被应用后做最终的布局调整。在布局的过程中，UIKit会对每个受影响的视图控制器执行以下操作：  

1. 根据需要更新视图控制器和它的视图的特征集合；参见“特性和尺寸变更合适发生？”
2. 调用视图控制器的 viewWillLayoutSubviews 方法。
3. 对当前的 UIPresentationController 对象调用 containerViewWillLayoutSubviews 方法。
4. 调用视图控制器根视图的 layoutSubviews 方法。该方法的默认实现会使用当前可用的约束来计算新的布局信息。该方法是贯穿视图层级结构的，它会调用每个子视图的layoutSubviews方法。
5. 将计算好的布局信息应用到视图上。
6. 调用视图控制器的 viewDidLayoutSubviews 方法。
7. 调用当前 UIPresentationController 对象的 containerViewDidLayoutSubviews 方法。

视图控制器可以使用viewWillLayoutSubviews 和 viewDidLayoutSubviews方法来执行额外的更新操作来影响布局过程。在布局之前，你可能需要添加或移除视图，更新视图的尺寸和位置，更新约束或更新其他与视图相关的属性。在布局之后，你可能会需要重新加载列表数据，更新其他视图的内容，或者为视图的尺寸和位置做出最终的调整。  
以下是几条高效的管理你的布局的建议：  

* 使用自动布局。你使用自动布局创建的约束可以灵活且容易适配你的内容到不同的屏幕尺寸上。
* 利用顶部和底部的布局建议。将内容放置在这些布局建议中将确保始终可见。顶部的布局元素存在在状态栏和导航栏的高度当中。同样的，底部的布局元素存在在页签栏和工具栏的高度中。
* 在添加或移除视图的时候记得要更新约束。如果你要自动的添加或删除视图，记得要更新相关的约束。
* 当你的视图控制器的视图在动画过程中移除临时约束。当一个视图在使用UIKit的核心动画时，应当在动画过程中移除你的约束并且在动画结束的时候添加回去。当你的视图的尺寸或位置在动画过程中发生改变的时候，要记得更新你的约束。

更多关于展示视图控制器和它们在视图控制器架构中所扮演的角色的相关信息，参见“展示和转场过程”。

### 高效的管理内存
虽然分配内存的大多数情况都是由你来决定，列表4-1列出了UIViewController中你最可能分配或释放内存的相关方法。大部分的释放操作都包含移除对象的强引用。为移除一个对象的强引用，应将该对象的属性和变量指针设置为nil。

列表4-1 分配和销毁内存的位置  

任务  | 方法  | 讨论 
------------- | -------------  | -------------
分配你的视图控制器所需的关键数据结构  | 初始化方法 | 您的自定义初始化方法 (无论它是名为 init 还是其他名字) 总是负责将视图控制器对象置于已知良好的状态。使用这些方法来分配需要的任何数据结构, 以确保正确的操作。
分配或加载需要显示在你的视图上的数据  | viewDidLoad | 使用viewDidLoad方法来加载你需要展示的数据。在调用此方法时，您的视图对象将被保证存在并处于已知的良好状态。
对于低内存通知做出反应  | didReceiveMemoryWarning | 使用该方法来释放所有与你的视图控制器相关的非必要的对象。尽可能多的释放更多的内存。
释放你的视图控制器所需的关键数据结构  | dealloc | 重写该方法，在当中执行最后时刻清理你的视图控制器类的相关内容。系统自动释放存储在实例变量和你的类的属性中的对象，所以你无需显式的释放这些对象。

## 实现一个容器视图控制器
容器视图控制器是一种从不同的视图控制器当中抽取内容到一个单一的用户界面的方式。容器视图控制器通常被用作简化导航和基于已有的内容创建新的用户界面。UIKit中的容器视图控制器的例子包括UINavigationController，UITabBarController，和 UISplitViewController，所有的这些都是优化你的用户界面的不同部分之间的导航的。
### 设计一个自定义的容器视图控制器
一个容器视图控制器在管理根视图和相关内容的时候是与内容类视图控制器几乎相同的。区别是容器视图控制器是从其他的视图控制器获取内容的。它获取的内容限于其他视图控制器的视图，视图是嵌入在视图控制器本身的视图层级中的。容器视图控制器会为任何嵌入的视图设置尺寸和位置，但原视图控制器仍旧管理着这些视图中的内容。  
当设计你自己的容器视图控制器的时候，要理解容器和被装载的视图控制器之间的联系。视图控制器之间的联系能够帮你知晓如何显示内容到屏幕上，以及如何在容器内部管理它们。在设计期间，要问问你自己以下的问题：  

* 容器所扮演的角色是什么，它的子控制器所扮演的角色是什么？
* 需要同时展示多少子视图？
* （如果不止一个子视图控制器的话）子视图控制器之间的关系是什么？
* 子视图控制器如何从容器中被添加或移除？
* 子视图控制器的尺寸和位置能够改变么？在什么情况下，这些改变会发生？
* 容器是否提供自己的任何装饰或与导航相关的视图？
* 容器和子视图控制器之间需要什么样的交流方式？是容器要通知特定的事件给它的子视图控制器还是通过UIViewController 类定义的标准函数？
* 容器的展示可以被配置成不同的方式么？如果可以的话，怎么做？

在你定义好了不同对象的角色之后，要实现一个容器视图控制器所要做的就很简单了。UIKit只要求你要在容器视图控制器和任何子视图控制器之间建立一个正式的父子关系。父子关系会确保孩子会收到任何系统相关的消息。除此之外，对于每个不同的容器而言，大部分真实的工作会发生在布局和管理孩子视图的过程中。你可以将视图放置在你的容器的任意位置，设置任何你想要的尺寸。你还可以添加自定义视图到视图层级中来提供装饰效果，或者辅助导航。

#### 示例：导航控制器
一个 UINavigationController 对象通过层级数据来支持导航。一个导航界面一次只展示一个子视图控制器。在界面的顶部会展示一个导航栏，它表示当前数据层级当中的位置，还会展示一个返回按钮用来返回上一层。向下一层级的导航交给子视图控制器，也可以由列表或按钮来实现。  
视图控制器之间的导航由导航控制器和它的孩子共同管理。当用户点击子视图控制器当中的一个按钮或者列表的一行时，子视图控制器会告诉导航控制器要将一个新的视图控制器压入当前视图。子视图控制器会处理新视图控制器的内容的相关配置，但导航控制器管理着转场动画。导航控制器还管理着导航栏，它有一个返回按钮，用来移除最上层的视图控制器。  
图5-1展示了导航控制器和它的视图之间的结构。大部分区域都被最上层的子视图控制器所填充，只有一小部分区域被导航栏所占据。  

图5-1 导航界面的结构
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_structure-of-navigation-interface_5-1_2x.png)  

无论什么环境下，一个导航控制器只会一次展示一个子视图控制器。导航控制器会调整它的子视图控制器来适应合适的位置。
#### 示例：分栏视图控制器

### 在IB中配置一个容器

### 实现一个自定义的容器视图控制器

#### 添加一个子视图控制器到你的内容中

#### 移除一个子视图控制器

#### 子视图控制器之间的转换

#### 为子视图控制器管理显示更新

### 构建一个容器视图控制器的一些建议

### 一个子视图控制器的代理控制

## 支持辅助功能

### 将辅助语音提示指针移动到指定的元素

### 响应特定的辅助语音提示的手势

#### 移开

#### 魔法点击

#### 三指滚动

#### 增加和减少

### 监听辅助功能的通知

## 保存和恢复状态

### 为保存的视图控制器进行标记

#### 选择高效的恢复

#### 排除一组视图控制器

#### 保存一个视图控制器的视图

### 在加载时恢复一个视图控制器

### 编解码你的视图控制器的状态

### 一些保存和存储你的视图控制器的建议

# 展示和转换

## 展示一个视图控制器

### 展示和转换过程

#### 展示样式

##### 全屏展示样式

##### 弹出样式

##### 聚焦样式

##### 自定义展示样式

#### 转换样式

#### 展示对比显示一个视图控制器

### 展示一个视图控制器

#### 显示视图控制器

#### 形式化展现视图控制器

#### 在弹出框中展示一个视图控制器

### 隐藏一个展示的视图控制器

### 展示一个在不同的故事版中定义的视图控制器

## 使用Segues

### 在视图控制器之间创建Segue

### 在运行时修改一个Segue的行为

### 创建一个展开的Segue

### 用程序初始化一个Segue

### 创建一个自定义的Segue

#### 一个Segue的生命周期

#### 实现一个自定义的Segue

## 自定义转场动画

### 转场动画的顺序

#### 转场代理事件

#### 自定义动画顺序

#### 转场上下文对象

#### 转场的协调者

### 使用自定义动画展示一个视图控制器

### 实现转场代理方法

### 实现你的动画对象

#### 获取动画参数

#### 创建转场动画

#### 在动画结束后进行清理

### 为你的转场动画添加交互

### 在转场旁边创建动画

### 使用你的动画来展现一个展示控制器

## 创建自定义展示

### 自定义展现的过程

### 创建一个自定义展示的控制器

#### 设置一个展示的视图控制器的大小

#### 管理和加载自定义视图的动画

### 交出你的展示视图的控制权给UIKit

### 适配不同尺寸的类

# 自适应性和大小的变化

## 自适应模型

### 特性的作用

### 什么时候特性和尺寸变更会发生？

### 不同的机型会有默认的控制尺寸的类

## 构建和适配界面

### 适应特性的改变

#### 配置你的故事版来处理不同的尺寸类

#### 改变一个子视图控制器的特性

#### 适配一个呈现的视图控制器为一个新的样式

#### 实现适配窗口的一些建议

### 响应尺寸变更 