[Auto Layout Guide 原文链接](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853)

# 开始
## 理解自动布局
自动布局会动态的计算在你的视图层级中所有视图的位置和大小，基于这些视图的约束。举例来说，你可以约束一个按钮与一个图片水平居中，让按钮的顶部始终与图片的底部保持8像素的距离。若图片的大小或位置改变了，按钮的位置也会自动变化进行调整匹配。  
这种基于约束的设计方式能够让你动态的构建用户界面，相应内部和外部的变化。
### 外部改变
当你的父视图的大小或形状改变时外部改变将会发生。伴随着改变的发生，你必须更新你的视图层级的布局，以便将可用空间更好的利用起来。以下是几种外部改变的来源：  

* 用户调整窗口大小 (OS X)。
* 用户进入或离开iPad上的分离式视图（iOS）。
* 设备改变方向（iOS）。
* 电话和音频录制栏展示或消失（iOS）。
* 你需要支持不同的尺寸类。
* 你需要支持不同的屏幕尺寸。

大部分这些变化都可能会在运行时发生，它们需要你的应用程序进行动态的反馈。其他类似于支持不同屏幕尺寸，表示应用程序适配不同的环境。即使屏幕尺寸不会在运行时改变，创建一个自适应的界面也能够让你的应用程序在iPhone 4S，iPhone 6 Plus甚至是在iPad上都能够良好运行。自动布局同样也是支持iPad上Slide Over 和 Split Views的关键组件。
### 内部改变
当视图的尺寸或用户界面上的控件发生改变时，内部改变将会发生。  
以下是几种内部改变的来源：  

* 应用程序展示的内容发生了改变。
* 应用程序支持国际化。
* 应用程序支持动态类型（iOS）。

当你的应用程序的内容发生改变时，新的内容可能需要一个与旧内容不同的布局。这通常发生在应用程序展示文字或图片时。举例来说，一款新闻类应用程序需要根据单个新闻文章来调整其布局尺寸。同样的，相册应用也必须处理范围广泛的图片大小和宽高比。  
国际化是让你的应用程序适应不同的语言，地区，文化的过程。一款国际化的应用程序的布局必须考虑不同语言和地区在应用程序中的正确显示。  
国际化对于布局主要有三方面的影响。首先，当你将你的用户界面翻译为一个不同的语言时，标签需要不同的空间。比如，用德语举例来说，通常就需要比英语更多的空间来展示。而日语通常需要较少的空间。  
其次，即使语言本身没改变，但日期和数字的格式可能从一个地区到另一个地区会改变。虽然这些变化通常比语言上的改变要小，但用户界面仍旧需要适配尺寸上的微小变化。  
第三，改变语言不只会影响文字的大小，还会影响布局的组织结构。不同的语言使用不同的布局方向，举例来说，英语使用从左到右的布局方向，而阿拉伯语和希伯来语使用的是从右到左的布局方向。通常来讲，用户界面的元素的顺序应当与布局方向匹配。如果一个按钮是在英文界面中的右下角，那么在阿拉伯语界面中它应当在左下角。  
最后，若你的iOS应用程序支持动态类型，用户可以改变你的应用程序中使用的文字大小。这会同时改变用户界面中文字元素的宽高。若用户在你的应用程序运行时改变了文字大小，那么文字和布局都要同时适配。
### 自动布局与基于frame布局对比
有三种方法来布局一个用户界面。你可以通过代码布局用户界面，也可以使用自动调整来自动的响应外部变化，或者你可以使用自动布局。  
传统上，应用程序通过代码的方式设置视图层级中的每个视图的位置来布局用户界面。frame定义了视图在其父视图坐标系统中的的原点，宽高。  

![](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/layout_views_2x.png)

要布局你的用户界面，你需要计算你的视图层级中的每个视图的位置和大小。随后，如果有变化发生，你必须重新计算所有受到影响的视图的frame。  
以编码的方式定义视图的frame会有极大的灵活性。当变化发生时，你可以直接设置你需要的改变。但因为你必须自己管理所有的变化，布局一个简单用户界面就需要大量的努力来设计，调试和维护。创建一个真正自适应的用户界面会增加一个数量级的难度。  
你可以使用自动调整大小来帮助减少这个过程的难度。自动调整定义了当视图的父视图的改变时，视图的frame如何改变。这简化了创建布局适配外部变化。  
不过，自动调整大小只支持可能布局的很小一部分子集。对于复杂的用户界面，你通常需要自己通过代码增加调整布局。此外，自动调整只会适配外部变化。它不支持内部变化。  
自动调整大小其实只是从编码布局上进行了迭代增强，而自动布局代表一种全新的范式。你无需考虑视图的frame，你需要考虑的是视图之间的关系。  
自动布局使用一系列的约束来定义你的用户界面。约束通常代表两个视图之间的关系。自动布局随后会根据视图之间的约束来计算每个视图的位置和大小。这造成了布局能够动态的响应外部和内部变化。  

![](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/layout_constraints_2x.png)

用来设计一组约束来创建特定行为的逻辑与用来编写代码或面向对象的逻辑非常不同。幸运的是，控制自动布局与控制其他编程任务没有差别。有两个基本步骤：首先你需要理解基于约束布局背后的逻辑，然后你要学习使用API。在学习其他编程任务时，你也要顺序的执行这些步骤。自动布局没有例外。  
本指南的其他部分是被设计用来让你容易迁移到自动布局。“没有约束的自动布局”一章对于用户界面背后的高度抽象简化创建自动布局进行了描述。“约束的剖析”一章提供了你自己创建自动布局交互需要理解的背景知识。“在用户编辑器中使用约束”描述了设计自动布局的工具，“编码方式创建约束”和“自动布局手册”两章详细描述了API。最后，“自动布局手册”一章展示了一系列不同复杂程度的样本布局，你可以学习它，将其应用在你的项目中，“调试自动布局”一章对于出问题之后如何修复提供了建议和工具。
## 没有约束的自动布局
Stack view提供了一种简单方式来利用自动布局的功能，而无需引入复杂的约束。一个单一的Stack view定义了一行或一列用户界面元素。Stack view会基于这些元素的属性来进行排版。  

* axis轴线：（仅用于UIStackView）定义了stack view的方向，是垂直还是水平。
* orientation方向：（仅用于NSStackView）定义了stack view的方向，是垂直还是水平。
* distribution分布：定义了沿轴线的视图的布局。
* alignment对齐：定义了垂直于stack view轴线的视图的布局。
* spacing间距：定义了临近视图的间距。

若要使用stack view，在界面编辑器中拖拽一个垂直或水平的stack view到画布上。然后将内容拖拽到stack 中。  
若一个对象拥有固定内容大小，它会以该尺寸出现在该stack中。若它的内容不是固定大小，界面编辑器会提供一个默认大小。你可以重新调整对象的大小，界面编辑器会添加约束来维持它的大小。  
要进一步的调试布局，你可以使用属性检查器修改stack view的属性。举例来说，下例使用了8像素间距和等距分布。  

![](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/IB_StackView_Simple_2x.png)

stack view也会基于它在排版视图上的内容和压缩比例优先级来布局。你可以使用尺寸检查器来修改这些。  

```
注意：你可以通过直接添加约束到排版视图上来进一步的修改布局；不过，你要尽量避免可能的冲突：一般说来，若一个视图的尺寸在给定区域内默认基于其内容尺寸，你可以在该区域内放心添加约束。更多约束冲突的相关信息，参见“不满足的布局”
```

此外，你可以将stack view嵌入到其他的stack view中来构建更复杂的布局。  

![](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/IB_StackView_NestedStacks_2x.png)

通常来讲，尽量多的使用stack view来管理你的布局。只有在单独通过stack view无法达到你的要求时才需要添加约束。  
更多使用stack view的相关信息，参见“UIStackView类目参考” 或 “NSStackView类目参考”。  

```
注意：尽管使用嵌入的stack view会增加用户界面的复杂度，但你无法摆脱对约束的需要。至少，你总是需要约束来定义最外层堆栈的位置（也可能是大小）。
```
## 约束的剖析
你的视图层级的布局被定义成一系列的线性等式。每个约束都代表着一个单一的等式。你的目的应该是声明一系列的等式，每个等式有且只有一个解。  
一个简单的等式如下所示。  

![](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/view_formula_2x.png)

这种约束状态是红色视图的前边距离蓝色视图的后部8像素。该等式有以下几部分组成：  

* Item 1（元素1）。代表等式中的第一个元素——在本例中，为红色视图。元素必须是一个视图或者布局参考。
* Attribute 1（属性1）。代表第一个元素的约束属性——本例中代表红色视图的前边距。
* Relationship（关系）。代表左边和右边的关系。关系可以有以下三种值之一：相等，大于或等于，小于或等于。在本例中，左边与右边相等。
* Multiplier（倍数）。代表属性2乘以该浮点数的值。在本例中，代表倍数是1.0。
* Item 2（元素2）。代表等式中的第二个元素——在本例中，是蓝色视图。与第一个元素不同，该元素左边可以为空。
* Attribute 2（属性2）。代表第二个元素的约束属性——本例中是蓝色视图的后边距。若第二个元素左边为空，该属性必须为“非属性”。
* Constant（常量）。代表常量，浮点位移——在本例中是8.0。该值会被添加到属性2的值中。

在我们的界面中，大部分约束都定义了两个元素之间的关系。这些元素可能代表视图或者布局参考。约束也可以定义同一个元素的不同属性之间的关系，比如，你可以设置一个元素的宽高比。你也可以将常量赋值给元素的宽高。当操作常量时，第二个元素的左边为空，第二个属性设置为“非属性”，倍数设置为0.0。
### 自动布局属性
在自动布局中，属性被定义成能够被约束的功能。通常来讲，它包含四个边（左右上下），也包括宽高和垂直水平的角。文本元素也有一个或多个基准线属性。  

![](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/attributes_2x.png)

有关完整属性列表，参见NSLayoutAttribute枚举。  

```
注意：虽然OSX和iOS都使用了NSLayoutAttribute枚举，它们的定义的值是有一些不同的。要想查看完整的属性列表，要确定你查看的是正确的平台的文档。
```
### 简单方程
等式中参数和属性的广泛可用性让你能够创建多种不同类型的约束。你可以定义视图之间的间距，对其视图的边，定义相关联的两个视图的大小，或者定义视图的缩放比。不过，不是所有的属性都是兼容的。  
有两种基本类型的属性。尺寸属性（比如宽高）和位置属性（比如前，左，上）。尺寸属性用来指定元素的大小，而无需指出其位置。位置属性用来指定元素相对于某些其他元素的位置。不过，它们不显示元素的大小。  
考虑到这些差异，以下规则适用：  

* 你不能强制设定一个尺寸属性给位置属性。
* 你不能给位置属性赋值常量。
* 使用位置属性时，你不能使用不一致的倍数（与1.0不一样的值）。
* 对于位置属性，你不能限制垂直属性给水平属性。
* 对于位置属性，你不能限制前或后属性给左或右属性。  
  
举例来说，设置一个元素的顶部为常量20而没有其他的上下文是没有意义的。你必须定义元素的位置属性与其他元素进行关联，比如，距离父视图的顶部20像素。不过，设置元素的高度为20像素没有任何问题。更多信息，参见“翻译值”。  
  
清单3-1展示了不同的一般约束的简单方程。  

```
注意：本章中所有的简单方程都使用伪代码展示。想查看使用真实代码的真实约束，参见“编码方式创建约束”或者“自动布局手册”
```

清单3-1 对于一般约束的简单方程

	// Setting a constant height
	View.height = 0.0 * NotAnAttribute + 40.0
 
	// Setting a fixed distance between two buttons
	Button_2.leading = 1.0 * Button_1.trailing + 8.0
 
	// Aligning the leading edge of two buttons
	Button_1.leading = 1.0 * Button_2.leading + 0.0
 
	// Give two buttons the same width
	Button_1.width = 1.0 * Button_2.width + 0.0
 
	// Center a view in its superview
	View.centerX = 1.0 * Superview.centerX + 0.0
	View.centerY = 1.0 * Superview.centerY + 0.0
 
	// Give a view a constant aspect ratio
	View.height = 2.0 * View.width + 0.0

### 相等而非赋值
要注意，“注意”中展示的等式代表相等，而非赋值。  
当自动布局解等式时，它并不只是将等式右边的值赋值给左边。而是它会计算属性1和属性2的值，并确定他们的关系为真。这意味着我们可以随意将等式两边的元素进行重新排列。比如，清单3-2中的等式与“注意”中的副本相同。  

清单3-2 翻转的等式  

	// Setting a fixed distance between two buttons
	Button_1.trailing = 1.0 * Button_2.leading - 8.0
 
	// Aligning the leading edge of two buttons
	Button_2.leading = 1.0 * Button_1.leading + 0.0
 
	// Give two buttons the same width
	Button_2.width = 1.0 * Button.width + 0.0
 
	// Center a view in its superview
	Superview.centerX = 1.0 * View.centerX + 0.0
	Superview.centerY = 1.0 * View.centerY + 0.0
 
	// Give a view a constant aspect ratio
	View.width = 0.5 * View.height + 0.0

```
注意：当重新排列元素时，要确定你要颠倒的倍数和常量。比如，常量8.0变为-8.0。2.0的倍数变为0.5。0.0的约束和1.0的倍数保持不变。
```
你会发现自动布局通常会提供多种方法来解决同一个问题。比较理想的方式是你应该选择最能够清晰描述你的理念的解决方案。不过，不同的开发者对于哪一种解决方案是最好的不会统一。在这里，保持一致要比正确要好。如果你选择一种方法并始终坚持下去，那么从长远来看，你会遇到越来越少的问题。比如，本指南使用了以下原则：  

1. 整数的倍数比分数的倍数要好。
2. 正数常量比负数常量要好。
3. 无论在任何位置，视图都应该出现在布局队列中：前后，上下。

### 创建无歧义的布局
当使用自动布局时，目标应当是提供一系列的等式，有且只有一个解。有歧义的约束会拥有超过一个解。无法满足的约束不会有合法的解。  
通常来讲，约束必须同时定义视图的尺寸和位置。假设父视图的尺寸已经被设置（比如，iOS上的屏幕的根视图），一个无歧义的满足布局需要的约束需要在视图的每个方向上都有两个约束（不算父视图）。不过，在选择哪个约束应该使用时，你有着多种选择。比如，一下三种布局都是无歧义的，满足的布局（只展示了水平方向的约束）:  

![](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/constraint_examples_2x.png)

* 第一种布局约束，视图的左边与父视图的左边相关。它还给视图一个固定的宽度。随后右边距的位置就能够根据父视图的尺寸和其他约束计算出来了。
* 第二种布局约束，视图的左边与父视图的左边相关。它还给视图的右边约束了与父视图的右边相关。视图的宽度随后酒呢能够根据父视图的尺寸和其他的约束计算出来了。
* 第三种布局约束，视图的左边与父视图的左边相关。它还将视图的中心与父视图对其。宽度和右边距的位置随后就能够根据父视图的尺寸和其他的约束计算出来了。

注意每种布局都有一个视图和两个水平的约束。在每种情况下，约束都完整定义了视图的宽度和水平位置。这就意味着所有的布局都是在水平轴上无歧义的，满足的布局。不过，这些布局并不等同于能够使用。要考虑到父视图的宽度改变的情况。  
在第一种布局中，视图的宽度不会改变。大部分情况下，这不是你想要的。实际上，一般来讲，你应该避免将常量大小赋值给视图。自动布局是被设计用来自动适应环境来创建布局的。当你基于一个视图固定尺寸的时候，你就将这种能力缩小了。  
可能不太明显，不过第二种和第三种布局是相同的效果：它们都维持视图和其父视图的固定间距，即使是父视图的宽度改变时。不过，它们并不相等。通常来讲，第二个例子比较容易理解，但第三个例子可能更有用，尤其是当你沿中线摆放一组元素时。始终要为你的布局选取最佳的方案。  
现在，考虑的稍微复杂一点。假设你要在iPhone上展示两个挨着的视图。你要确保他们在所有方向上都有着较好的间距，并且始终拥有相同宽度。它们也应当在设备旋转的时候调整尺寸。  
以下图片展示的视图，在水平和垂直方向上：  

![](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Blocks_Portrait_2x.png)  

![](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Blocks_Landscape_2x.png)

那么这些约束应该是什么样呢？下图展示了一种比较直接的解决方案：  

![](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/two_view_example_1_2x.png)

上述解决方案使用的是以下的约束：  

	// Vertical Constraints
	Red.top = 1.0 * Superview.top + 20.0
	Superview.bottom = 1.0 * Red.bottom + 20.0
	Blue.top = 1.0 * Superview.top + 20.0
	Superview.bottom = 1.0 * Blue.bottom + 20.0
 
	// Horizontal Constraints
	Red.leading = 1.0 * Superview.leading + 20.0
	Blue.leading = 1.0 * Red.trailing + 8.0
	Superview.trailing = 1.0 * Blue.trailing + 20.0
	Red.width = 1.0 * Blue.width + 0.0

根据之前的惯例，这种布局有两个视图，四个水平方向的约束，以及四个垂直方向的约束。虽然这不是万无一失的指南，但它是一个快速的迹象表明你是在正确的轨道上。更重要的是，约束对于视图的大小和位置都进行了单独设定，这就形成了无歧义的，满足条件的布局。移除任何约束，布局都会变成有歧义的。而添加额外的约束，你又会增加冲突的风险。  
同样，这仍不是唯一的解决方案。以下是与之相等的合理解决方案：  

![](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/two_view_example_2_2x.png)  

无需将蓝色视图的顶部和底部固定在其父视图上，你只需对其蓝色视图的顶部和红色视图的顶部即可。类似的，你需要将蓝色视图的底部和红色视图的底部对其。约束如下所示。

	// Vertical Constraints
	Red.top = 1.0 * Superview.top + 20.0
	Superview.bottom = 1.0 * Red.bottom + 20.0
	Red.top = 1.0 * Blue.top + 0.0
	Red.bottom = 1.0 * Blue.bottom + 0.0
 
	//Horizontal Constraints
	Red.leading = 1.0 * Superview.leading + 20.0
	Blue.leading = 1.0 * Red.trailing + 8.0
	Superview.trailing = 1.0 * Blue.trailing + 20.0
	Red.width = 1.0 * Blue.width + 0.0

示例仍旧有两个视图，四个水平方向约束，四个垂直方向约束。同样也形成了无歧义的满足条件的布局。

	但哪种比较好呢？
	这些解决方案都形成了合理的布局。那么哪种比较好呢？
	遗憾的是，事实上客观的不能够证明一种解决方案比另一种要更好。每种都有其自己的优势和缺点。  
	第一种解决方案在一个视图被移除时会比较灵活。将一个视图从视图层级中移除同样也会移除其所有的关联的约束。所以，如果你移除红色视图的话，蓝色视图会留下三个约束。你需要添加一个约束就能够达到合理布局了。而第二种解决方案，移除红色视图的话，将会让蓝色视图只拥有一个约束。
	另一方面，在第一种解决方案中，若你想要视图的顶部和底部对其，你必须确保它们的顶部和底部约束使用的是同样的常量值。若果你改变其中的一个常量，你必须要记得改变另一个常量。
	
### 约束不相等
到目前为止，所有的例子都展示的是约束是相等的情况，但这只是一面。约束也能够表示不相等的情况。尤其是约束关系能够是相等，大于或等于，或者是小于或等于。  
比如，你可以使用约束来定义视图的最小或最大尺寸（清单3-3）。  

清单3-3 赋值一个最小和最大尺寸  

	// Setting the minimum width
	View.width >= 0.0 * NotAnAttribute + 40.0
 
	// Setting the maximum width
	View.width <= 0.0 * NotAnAttribute + 280.0

当你开始使用不相等时，每个视图的每个方向的两个约束的规则就被打破了。你可以将一个单一的相等关系替换为两个不等的。在清单3-4中，单一的相等关系以及成对的不等关系的效果是一样的。  

清单3-4 替换一个单一相等关系为两个不等  

	// A single equal relationship
	Blue.leading = 1.0 * Red.trailing + 8.0
 
	// Can be replaced with two inequality relationships
	Blue.leading >= 1.0 * Red.trailing + 8.0
	Blue.leading <= 1.0 * Red.trailing + 8.0

但反过来不一定对，因为两个不等关系不一定等于一个相等关系。比如，在清单3-3中的不等关系限制了视图的宽度的可呢取值范围——但对于它们本身而言，它们没有定义宽度。你还是需要额外的水平约束来在这个范围内定义视图的位置和尺寸。

### 约束优先级
默认的，所有的约束都是必须的。自动布局必须计算一种能够满足所有约束的解。如果不能的话，会有错误。自动布局会打印关于不满足约束的相关信息到控制台，并选择一个约束来中断。随后会抛弃中断的约束来重新计算一个解。更多相关信息，参见“不满足的布局”。  
你也可以创建可选的约束。所有的约束都有一个在1到1000之间的优先级。拥有1000的优先级的约束是必须的。所有其他的约束都是可选的。  
当计算解时，自动布局会从最高到最低优先级的顺序来满足所有的约束。若不能够满足可选约束的话，该约束会被跳过，从下一个约束开始继续。  
即使一个可选的约束不能够被满足，它依然能够影响布局。在跳过约束之后如果在布局中还有模糊的情况存在的话，系通过选择一个最接近约束的解决方案。在这种情况下，不满足的可选约束会表现为将视图拉至它们本身。  
可选约束和不相等的情况经常同时发生。举例来说，在清单3-4中，你可以为连个不等的约束提供不同优先级。大于或等于的关系可以是必选的（优先级为1000），小于或等于的关系可以是低优先级的（优先级250）。这意味着蓝色视图不能靠近红色视图超过8像素。不过，其他的约束能够将其拉至远处。同样，可选约束也会将蓝色视图朝着红色视图拉近，会保证尽量靠近到8像素远，给予其他布局中的约束。  

	注意
	不要觉得使用所有1000个优先级值有压力。实际上，优先级通常就是系统定义的几种，低（250），中（500），高（750），以及必须（1000）。你可以将约束定义成高于或低于这些值的一两点，以帮助防止关联。若你使用的远超过它的话，你可能就需要重新检视你的布局逻辑了。
	对于iOS中定义的一系列预定义好的约束常量，参见UILayoutPriority枚举。对于OSX，参见布局优先级常量。

### 固定的内容尺寸
到目前为止，所有的例子都使用约束定义了视图的尺寸和位置。不过，有些视图对于其本身的内容会给予一个自然尺寸。这要参考它们的“固定内容尺寸”。举例来说，一个按钮的固定内容尺寸是其标题加上一小部分的间距。  
不是所有的视图都有固定内容尺寸。对于拥有的视图来说，固定内容尺寸能够定义视图的高和宽。清单3-1展示了一些例子。  

清单3-1 一些常用控件的固定内容尺寸  

| 视图  | 固定内容尺寸  |
|:------------- |:---------------:|
| UIView 和 NSView      | 没有固定内容尺寸 |
| Sliders      | iOS上只定义的宽度，OSX上根据slider的类型能够同时定义高和宽 |
| Labels, buttons, switches, and text fields | 同时定义了高和宽 |
| Text views and image views | 固定内容尺寸能够变化      |

固定内容尺寸是基于视图的当前内容的。label或者button的固定内容尺寸是基于要显示的文字数量和使用的字体来决定的。对于其他视图，固定内容尺寸要更复杂一些。比如，一个空白图片不会有固定内容尺寸。只要你添加一个图片，固定内容尺寸就会被设置为图片的大小。  
text view的固定内容尺寸会根据内容变化，无论其是否能够滚动，并且还有其他的约束应用在视图上。比如，对于可以滚动的视图是没有固定内容尺寸的。对于禁用滚动的视图，默认情况下，视图的内部内容大小将根据文本的大小进行计算，而无需换行。再比如，若文本中没有回车，文本会被当做一个单行的需要布局的文本来计算宽高。若你添加约束来限定视图的宽，固定内容尺寸会根据其给定的宽度定义展示文本的高度。  
自动布局会在视图的每个方向上使用一对约束来展示视图的固定内容大小。内容会将视图向内拉伸以便视图能够紧贴着内容。压阻会将视图向外推，以便它不会切割内容。  

![](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/intrinsic_content_size_2x.png)  

这些约束会使用如清单3-5中的不相等关系来定义。在这，IntrinsicHeight和IntrinsicWidth常量代表视图的固定内容大小的高和宽值。  

清单3-5 压阻和内容紧贴方程

	// Compression Resistance
	View.height >= 0.0 * NotAnAttribute + IntrinsicHeight
	View.width >= 0.0 * NotAnAttribute + IntrinsicWidth
 
	// Content Hugging
	View.height <= 0.0 * NotAnAttribute + IntrinsicHeight
	View.width <= 0.0 * NotAnAttribute + IntrinsicWidth


#### 固定的内容尺寸对比适配尺寸

### 解释值

## 在界面构建器中使用约束

# 自动布局手册

## Stack Views

### 简单Stack View

#### 视图和约束

#### 属性

#### 讨论

### 嵌套Stack Views

## 简单约束

## 拥有固定内容尺寸的视图

# 调试自动布局

# 高级自动布局

## 编码方式创建约束

### 布局锚点

### NSLayoutConstraint类

### 可视化格式语言

## 尺寸类特定布局

## 结合滚动视图

## 结合自适应列表视图单元格

## 改变约束

# 附录