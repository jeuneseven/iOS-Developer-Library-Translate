[View Controller Programming Guide for iOS 原文链接](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457)

# 概览
## 视图控制器所扮演的角色
视图控制器是你的应用程序内部架构的基础。每个应用程序都至少含有一个视图控制器，大部分应用程序都有很多个。每个应用程序都会管理着一份你的应用程序的用户界面以及该用户界面与底层数据的交互。视图控制器同样也会改善不同的视图界面之间转换的过渡。  
由于它在你的应用程序当中扮演着如此重要的角色，视图控制器几乎会成为你做任何事的中心。UIViewController类定义了很多方法和属性来管理你的视图，处理事件，从一个视图控制器过渡到另一个以及协调你的应用程序的其他部分。你可以继承UIViewController（或者集成它的子类）然后添加自己需要实现的行为的代码即可。  
一共有两种类型的视图控制器：  

* 内容类的视图控制器管理着你的应用程序的分散的内容，它是你主要创建的视图控制器。
* 容器类视图控制器从其他的视图控制器收集信息（被称作子视图控制器）以一种简便的导航方式展示出来或者以不同的模态方式展示这些视图控制器的内容。

大部分应用程序是这两种类型视图控制器的混合体。
### 视图的管理
一个视图控制器的最重要的角色是管理视图的层级。每个视图控制器都拥有一个根视图，它将所有的视图控制器的内容都封装进去。通过这个根视图，你可以添加你需要展示的视图内容。图1-1展示了视图控制器和它的视图之间的内部关系。视图控制器将一直持有根视图，并且每个视图对于它的子视图都是强引用。  

图1-1 视图控制器和它的视图之间的关系  

![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_ControllerHierarchy_fig_1-1_2x.png)

	注意：通常使用outlets来访问在你的视图控制器层级当中的其它视图。由于一个视图控制器管理着所有它的视图的内容，outlets能够让你持有你需要的视图的引用。outlets本身在视图被从故事版加载的时候自动连接到了实际的视图对象。  

内容类的视图控制器通过它本身来管理所有的视图。容器类的视图控制器管理它本身的视图以及一个或多个子视图的根视图。容器类本身不会管理它的子视图的内容。它仅仅管理根视图，尺寸并根据容器的设计来布局。图1-2展示了一个split视图控制器以及它的子视图之间的关系。split视图控制器管理了它的子视图的总体尺寸和位置，但是子视图控制器管理了这些视图的实际内容。

图1-2 视图控制器能够管理其它视图控制器的内容

![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_ContainerViewController_fig_1-2_2x.png)  

更多关于管理你的视图控制器视图的相关信息，参见“管理视图布局”。

### 数据的封装
一个视图控制器在它管理的视图和你的应用程序的数据之间起到了一个调度的作用。UIViewController类的方法和属性能够让你管理你的应用程序的可视化部分。当你继承UIViewController类的时候，你可以添加任何你需要管理你的数据的变量到你的子类当中。添加一个自定义的变量回创建一个类似于图1-3当中的关系，当视图控制器持有你的数据，视图将会用它来展示那个数据。将数据从两者之间进行传递是你的责任。  

图1-3 一个视图控制器在数据对象和视图对象之间进行调度

![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_CustomSubclasses_fig_1-3_2x.png)

你应当在你的视图控制器和数据对象之间始终维护一个清晰的责任关系。大部分确认数据结构完整性的逻辑都应该在数据对象当中实现。视图控制器可能会需要验证从视图当中输入的内容，然后将其打包成你的数据需要的格式，但是你应该确保视图控制器在管理实际数据的过程中担任尽量少的角色。  
UIDocument对象是一种能够让数据与你的视图控制器分离的管理方式。文档对象是一个控制器对象，它知道如何永久存储一个可读写的数据。当你继承它时，你可以添加任何你需要的逻辑和方法来处理数据，你可以将其传递到一个视图控制器或者你的应用程序的其他部分。视图控制器可能会保留一份它接收到的数据的拷贝，以便将其更容易的更新到视图上，不过文档本身还是拥有实际的数据。
### 用户的交互
视图控制器是响应类型的对象，并且能够处理从响应者链条中传递过来的事件。尽管它能够这么做，但是视图控制器很少直接处理触摸事件。通常，是由视图来处理它们本身的触摸事件，然后将其结果发送给一个相关的代理方法或者目标对象，通常是一个视图控制器。所以大部分在视图控制器当中的事件都是使用代理方法或者目标函数来处理的。  
更多关于在视图控制器当中实现目标函数的相关信息，参见“处理用户交互”。更多关于处理其他类型的事件的相关信息，参见“iOS事件处理指南”。
### 资源的管理
视图控制器对其视图及其创建的任何对象承担全部责任。UIViewController类会自动的处理视图管理的大部分内容。举例来说，UIKit自动处理不再需要的视图相关的资源。在你的UIViewController子类当中，你应当管理所有由你创建的对象。  
当可用的内存较少的时候，UIKit会要求应用程序释放任何不再需要的资源。其中一种方式是调用你的视图控制器当中的didReceiveMemoryWarning方法。使用该方法来移除你不再需要的对象的引用或在以后重新创建。比如，你可以使用该方法移除缓存的数据。当发生低内存警告的时候，尽你所能的释放更多的内存是很重要的。应用程序如果消耗过多的内存的话，可能会被系统完全终止来释放内存。
### 自适应性
视图控制器要负责展示它的视图，并且要适配那些展示的视图来匹配底层环境。每款iOS的应用程序都应该能够运行在iPad上以及不同尺寸的iPhone手机上。使用一个单一的视图控制器来适配它的视图来改变空间所需更为简单，而不是为不同的设备提供很多的视图控制器和视图层级。  
在iOS上，视图控制器要处理各种粗细粒度的尺寸变更。当一个视图控制器的特性发生改变的时候会有粗粒度的变更。特性是用来描述整体环境的一种属性，比如展示的缩放。视图控制器有两个非常重要的特性就是垂直方向和水平方向的尺寸控制类，它们表示视图控制器在给定的尺寸当中有多少空间能够用来展示。你可以使用尺寸类的变更来作为改变你的视图布局的方式，如图1-4所示。当水平尺寸控制类为regular（分散对齐）的时候，视图控制器会利用额外的水平空间来布局它的内容。当水平尺寸控制类为compact（紧凑对齐）的时候，视图控制器会对其内容进行垂直布局。  

图1-4 适配视图来进行尺寸类变更
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_SizeClassChanges_fig_1-4_2x.png)  

在一个给定的尺寸类当中，随时都会发生很多的细粒度的尺寸变更。当用户将iPhone从竖直方向转为水平方向，尺寸类可能不会改变，而屏幕的尺寸通常会变更。当你使用自动布局的时候，UIKit自动的调整视图的尺寸和位置来匹配新的尺寸。视图控制器可以根据需要来进行额外的调整。  
更多关于自适应性的相关信息，参见“自适应模型”。
## 视图控制器的层级结构
你的应用程序当中的视图控制器之间的关系定义了每个视图控制器所需要的行为。UIKit框架期望你以规定的方式来使用视图控制器。维持视图控制器之间适当的关系，确保在视图控制器被需要的时候能够自动调用适当的行为发送给对应的视图控制器。如果你打破了规定的包含和展示关系，你的应用程序的某些部分将会不出意外的停止某些行为。
### 根视图控制器
根视图控制器是视图控制器层级的根节点。每个窗口都拥有一个根视图控制器，它的内容会填充该窗口。根视图控制器定义了最初能够被用户所见的内容。图2-1展示了根视图控制器和窗口之前的关系。由于窗口本身没有能够展示的内容，视图控制器的视图提供了所有它的内容来展示。  

图2-1 根视图控制器
![](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG-root-view-controller_2-1_2x.png)  

UIWindow对象的rootViewController属性可以用来让根视图控制器访问。当你使用故事版来配置你的视图控制器的时候，UIKit会在启动的时候自动的设置这个属性的值。对于代码创建的窗口而言，你必须自己设置根视图控制器。
### 容器视图控制器

### 展现视图控制器

## 设计指南

### 尽量使用系统支持的视图控制器

### 尽量使每个视图控制器孤立

### 使用根视图的时候，将其仅作为其它视图的容器

### 要知晓你的数据的生命周期

### 要适应改变

# 视图控制器的定义

## 定义你的子类

### 定义你的UI

### 处理用户的交互

### 在运行时展示你的视图

### 管理视图布局

### 高效的管理内存

## 实现一个容器视图控制器

### 设计一个自定义的容器视图控制器

#### 示例：导航控制器

#### 示例：分栏视图控制器

### 在IB中配置一个容器

### 实现一个自定义的容器视图控制器

#### 添加一个子视图控制器到你的内容中

#### 移除一个子视图控制器

#### 子视图控制器之间的转换

#### 为子视图控制器管理显示更新

### 构建一个容器视图控制器的一些建议

### 一个子视图控制器的代理控制

## 支持辅助功能

### 将辅助语音提示指针移动到指定的元素

### 响应特定的辅助语音提示的手势

#### 移开

#### 魔法点击

#### 三指滚动

#### 增加和减少

### 监听辅助功能的通知

## 保存和恢复状态

### 为保存的视图控制器进行标记

#### 选择高效的恢复

#### 排除一组视图控制器

#### 保存一个视图控制器的视图

### 在加载时恢复一个视图控制器

### 编解码你的视图控制器的状态

### 一些保存和存储你的视图控制器的建议

# 展示和转换

## 展示一个视图控制器

### 展示和转换过程

#### 展示样式

##### 全屏展示样式

##### 弹出样式

##### 聚焦样式

##### 自定义展示样式

#### 转换样式

#### 展示对比显示一个视图控制器

### 展示一个视图控制器

#### 显示视图控制器

#### 形式化展现视图控制器

#### 在弹出框中展示一个视图控制器

### 隐藏一个展示的视图控制器

### 展示一个在不同的故事版中定义的视图控制器

## 使用Segues

### 在视图控制器之间创建Segue

### 在运行时修改一个Segue的行为

### 创建一个展开的Segue

### 用程序初始化一个Segue

### 创建一个自定义的Segue

#### 一个Segue的生命周期

#### 实现一个自定义的Segue

## 自定义转场动画

### 转场动画的顺序

#### 转场代理事件

#### 自定义动画顺序

#### 转场上下文对象

#### 转场的协调者

### 使用自定义动画展示一个视图控制器

### 实现转场代理方法

### 实现你的动画对象

#### 获取动画参数

#### 创建转场动画

#### 在动画结束后进行清理

### 为你的转场动画添加交互

### 在转场旁边创建动画

### 使用你的动画来展现一个展示控制器

## 创建自定义展示

### 自定义展现的过程

### 创建一个自定义展示的控制器

#### 设置一个展示的视图控制器的大小

#### 管理和加载自定义视图的动画

### 交出你的展示视图的控制权给UIKit

### 适配不同尺寸的类

# 自适应性和大小的变化

## 自适应模型

### 特性的作用

### 什么时候特性和尺寸变更会发生？

### 不同的机型会有默认的控制尺寸的类

## 构建和适配界面

### 适应特性的改变

#### 配置你的故事版来处理不同的尺寸类

#### 改变一个子视图控制器的特性

#### 适配一个呈现的视图控制器为一个新的样式

#### 实现适配窗口的一些建议

### 响应尺寸变更 