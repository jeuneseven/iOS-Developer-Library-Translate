[Objective-C Runtime Programming Guide 原文链接](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048)

# 介绍
OC语言尽可能的将一些判断决策从编译链接时推迟到运行时。无论何时，它都是动态的处理事务。这意味着语言不近需要一个编译器，还需要运行时系统来执行编译的代码。对于OC语言来说，运行时系统扮演了一种操作系统的角色；是它使得语言能够正常工作。  
本文档窥探了NSObject类以及OC程序是如何与运行时系统进行交互的。文档中还检测了在运行时动态加载一个新类并检测了其范式，以及向上转发其消息给其他对象。本文档还提供了有关你的程序运行时如何查找对象的相关信息的一些信息。  
你应该在读本文档时获取到一些OC运行时系统是如何工作的相关知识，并且知道如何利用它。不过，通常情况下，你应该没有什么理由需要了解和理解这些材料来编写Cocoa应用程序。  

## 本文档的组织结构
本文档包含以下章节：  

* 运行时版本和平台
* 与运行时交互
* 消息
* 动态方法的解决方案
* 消息向上转发
* 类型编码
* 声明属性

## 另请参阅

《OC运行时参考》一文描述了OC运行时支持库的数据结构和函数。你的应用程序可以使用该接口与OC运行时系统进行交互。比如，你可以添加类或者方法或者获取已加载的类的所有类定义的列表。  
《使用OC编程》一文描述了OC语言。  
《OC发布说明》描述了在最近发布的OSX版本中的OC运行时的一些改变。

# 运行时版本和平台
在不同的平台上的OC运行时版本是不同的。  
## 历史版本和现代版本
有两个OC运行时版本——“现代”和“历史”版本。现代版本是在OC2.0引入的，并且包含了大量的新功能。历史版本的运行时编程接口在“OC 1 运行时参考”中有相关描述；现代版本的运行时编程接口在“OC运行时参考”中有描述。  
最值得注意的新功能是实例变量在现代运行时中是“non-fragile”：  

* 在历史版本的运行时中，如果你改变一个实例变量在类中的布局，你必须重新编译继承该类的类。
* 在现代运行时版本中，如果你改变一个实例变量在类中的布局，你无须重新编译继承该类的类。

此外，现代运行时对于生命的属性支持实例变量自动合成（参见“OC编程语言”中的“声明属性”一节）。

## 平台
iPhone应用程序以及运行在OSX v10.5之后版本的64位程序使用的是现代版本的运行时。  
其他程序（OSX桌面的32位程序）使用的是历史版本的运行时。  
# 与运行时交互
OC程序与运行时系统进行交互是通过三个不同的层级：通过OC源代码；通过定义在NSObject类（Foundation框架中）中的方法；通过直接调用运行时函数。  
## OC源代码
大部分情况下，运行时系统是自动在后台工作的。你可以通过编写和编译OC源代码使用它。  
当你编译包含OC类和方法的代码时，编译器会创建数据结构和函数调用来实现语言的动态特性。数据结构会捕获在类和分类以及协议中发现的定义的信息；包含“OC编程语言”中“定义类”和“协议”中讨论的类和协议对象，以及方法选择器，实例变量模板和其他从源代码中抽取到的信息。运行时函数的主要工作是发送消息，这在“消息”一节中有相关描述。它是通过源代码消息表达式调用的。    
## NSObject方法
大部分Cocoa中的对象都是NSObject类的子类，所以大部分对象都继承了它所定义的方法。（有个比较明显的例外是NSProxy类；参见“消息向上转发”查看更多信息。）因此它的方法就确定了每个实例和类对象的特定行为。不过，在一些例外中，NSObject类只定义了如何做某些事的模板；并没有提供所有的必须的代码。  
举例来说，NSObject类定义了description实例方法，它会返回了一个描述类的内容的字符串。这主要用来调试GDB的print-object命令，来打印从该方法返回的字符串。NSObject实现该方法时并不知道有什么类包含在内，所以它返回一个名字和对象的地址作为字符串。继承NSObject就能够实现该方法并返回更多的细节。比如，Foundation框架的NSArray类返回了它所包含的对象的描述列表。  
一些NSObject方法会直接查询运行时系统信息。这些方法能够允许对象执行内省功能。我们列举一下这些方法：class方法会询问一个对象来确定它的类；isKindOfClass:和isMemberOfClass:方法会检测一个对象在其继承层级中的位置；respondsToSelector:方法会标识一个对象能否接受一个特定的信息；conformsToProtocol:方法会标识一个对象是否实现了定义在一个特定协议中的方法；methodForSelector:方法会提供一个方法的实现的地址。类似这样的一些方法能够让对象对其本身进行内省。  
## 运行时函数
运行时系统是一个动态共享库，它由一组公开的在头文件中定义的函数和数据结构组成，存在于/usr/include/objc目录中。大多数这些函数都允许你直接使用纯C语言来复制编译器在编写OC代码时的操作。其他功能通过导出NSObject类的方法的基础来构成。这些函数能够用来开发其他运行时系统的接口，并且产出的工具也能够增强开发环境；他们在OC编程中并不需要。不过，少量的运行时函数可能在编写OC程序中的某些长河中有用。所有这些函数都在文档“OC运行时参考”中。
# 消息
本章描述了消息表达式如何转换为objc_msgSend函数调用，以及如何按照名称引用方法。随后阐释了你如何利用objc_msgSend方法以及（如果需要的话）如何绕过动态绑定。  
## objc_msgSend函数
在OC当中，消息直到运行之前不会绑定到方法实现。编译器会将一条消息表达式，

	[receiver message]

转换为调用一个消息函数，objc_msgSend。该方法会将消息的接收者以及在消息中提到的方法名——也就是函数选择器——作为两个主要的参数：  

	objc_msgSend(receiver, selector)

其他的在消息中传递的参数也同样被传递给objc_msgSend：

	objc_msgSend(receiver, selector, arg1, arg2, ...)

消息函数会尽可能做到动态绑定：  

* 首先会查找选择器所引用的程序（方法实现）。当同样的方法能够被不同的类分别实现时，精确到哪个程序实现是根据查找到的类的接收者来决定的。
* 然后调用程序，传递给他接收对象（一个指向数据的指针），以及其他指定给函数的参数。
* 最终，传递程序的返回值作为其自己的返回值。

```
注意：编译器会生成调用消息函数。你不应该在你自己编写的代码中直接调用它。
```

消息传递的关键在于编译器为每个类和对象生成的结构。每个类结构都包含以下两个基本要素：  

* 一个指向父类（superclass）的指针。
* 一个类分发表（dispatch table）。

## 使用隐含的参数

## 获取一个方法的地址

# 动态方法的解决方案
本章描述了你该如何动态的提供一个方法的实现。  
## 动态方法的解决方案
当你想动态的提供一个方法的实现时，是有解决方案的。举例来说，OC声明一个属性的功能（参见“OC编程语言”一文中的“声明属性”部分）包含 @dynamic 指令：  

	@dynamic propertyName;

这会告诉编译器有关这个对象的方法将会动态的提供。  
你可以实现方法 resolveInstanceMethod: 和 resolveClassMethod: 分别来动态的为一个给定的示例和类方法selector提供动态的实现。  
一个OC方法简单来说其实是一个带有至少两个参数的C函数——self和_cmd。你可以使用函数class_addMethod添加一个函数到一个类，作为该类的方法。所以，给出下列函数：  

	void dynamicMethodIMP(id self, SEL _cmd) {
 	   // implementation ....
	}
你可以动态的将其添加到一个类作为方法(调用resolveThisMethodDynamically)使用resolveInstanceMethod: 类似这样：  

	@implementation MyClass
	+ (BOOL)resolveInstanceMethod:(SEL)aSEL
	{
	    if (aSEL == @selector(resolveThisMethodDynamically)) {
   		       class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
       	   return YES;
	    }
   	 return [super resolveInstanceMethod:aSEL];
	}
	@end

## 动态加载

# 消息向上转发

## 向上转发

## 向上转发和多重继承

## 代理对象

## 向上转发和继承

# 类型编码

# 声明属性

## 属性类型和函数

## 属性类型字符串

## 属性描述示例