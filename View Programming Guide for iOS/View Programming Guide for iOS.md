[View Programming Guide for iOS 原文链接](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503)

# 介绍
## 关于窗口和视图
在iOS当中，你可以使用窗口和视图来展示你的应用程序的内容到屏幕上。窗口本身没有任何可视化的内容，但它为你的应用程序的视图提供了一个基本的容器。视图可以定义窗口的一部分用来填充你想填充的内容。举例来说，你可以使用视图来展示图片、文字、图形或者任何它们之间的组合。你还可以使用视图来组织管理其它的视图。
### 概览
每款应用程序都至少含有一个窗口和一个视图来展现内容。UIKit和其它的系统框架都提供了定义好的视图让你用来展示你的内容。这些视图从简单的按钮、标签到复杂的视图，比如列表、选择器以及滚动视图应有尽有。若定义好的视图没有提供你想要的功能的话，你还可以定义自定义的视图来管理绘制贺事件处理。
#### 视图管理着你的应用程序的可视化界面
视图是UIView类（或其子类）的实例对象，它在你的应用程序的窗口中管理着一个矩形区域。视图负责绘制内容，处理多点触摸事件以及管理子视图的布局。绘制包括使用核心制图、OpenGL ES、或者UIKit等制图技术来在一个视图的矩形区域绘制图形，图片以及文字。一个视图负责在其矩形区域中使用手势或者直接处理触摸事件。在视图层级中，父视图负责对其子视图进行动态的设置位置和大小。这种能够动态的修饰子视图的能力让你的视图能够根据情况进行调整，比如屏幕旋转和动画。  
你可以将视图视作构建你的视图界面的模块。通常使用多个视图来构建视图层级而不是只用一个来展示所有你的内容。每个视图层级中的视图都展示了你的视图界面中的一个特别的部分，它通常已经作为一种特殊类型的内容优化过了。举例来说，UIKit为展示图片，文字和其它类型的内容都有着指定的视图类型。  

```
相关章节：视图和窗口架构，视图
```
#### 窗口协调展示你的视图
窗口是UIWindow类的实例对象，它处理了你的应用程序用户界面的所有展示内容。窗口和视图（以及持有它的视图控制器）一起管理用户交互，响应变更以及视图的可视化层级。大部分情况下，你的窗口不需要做出任何改变。一旦窗口被创建，它将保持不变，只有它所显示的视图才会更改。每个应用程序至少含有一个窗口来展示应用程序的用户界面到设备的主屏幕上。如果有额外的展示设备被连接到设备上，应用程序也可以创建第二个窗口来将内容展示到该屏幕上。

```
相关章节：窗口
```
#### 动画对界面的改变为用户提供了可视化的反馈
动画为用户提供了视图层级变更的可视化反馈。系统为模态化展示视图和一组不同视图之间的转换定义了标准动画。不过，视图的多个属性都能够被直接动画展示。举例来说，通过动画你可以改变一个视图的透明度，它在屏幕上的位置，它的尺寸，它的背景颜色或者其它的属性。若你直接作用于视图底层的核心动画层对象的话，你还可以执行更多的动画。
```
相关章节：动画
```
#### 界面编辑器的作用
界面编辑器是一款你可以用来生动的构建和配置你的应用程序的窗口和视图的应用程序。使用界面编辑器你能够将你的视图汇集到一起，将其放置在一个nib文件当中，后者是存储你的视图和其它对象的静态版本的一种资源文件。当你在运行时加载一个nib文件的时候，它当中的对象将会重新组合成实际的对象，你的代码就能够以编码的方式对其进行操作了。  
界面编辑器大大简化了你在创建应用程序用户界面时的操作。由于iOS对于界面编辑器和nib文件的支持是贯穿始终的，你在你的应用程序设计期间只需要做很少的工作就能够将nib文件结合进去。  
更多关于如何使用界面编辑器的相关信息参见“界面编辑器用户指南”。关于视图控制器如何管理在nib文件中包含的视图，参见“iOS视图控制器编程指南”中的“创建自定义内容的视图控制器”一节。
### 另请参见
由于视图是很复杂和灵活的一种对象，不可能在一篇文档中涵盖所有它的内容。不过，以下有几篇其它的文档能够帮助你整体学习视图管理和用户界面的其它方面。  

* 视图控制器在管理你的应用程序的视图中是很重要的一部分。视图控制器在单个视图层次结构中主持所有视图并帮助这些视图展示到屏幕上。更多关于视图控制器以及它所扮演的角色，参见“iOS视图控制器编程指南”。
* 在你的应用程序中，视图扮演者手势和触摸事件的关键接受者角色。更多关于适用手势和直接处理触摸事件的相关信息，参见“iOS事件处理指南”。
* 自定义视图必须使用相应的绘图技术来渲染它的内容。更多如何使用这些技术来绘制你自己的视图的相关信息，参见“iOS绘图和印刷指南”。
* 在标准视图动画无法满足需求的地方，你可以使用核心动画。更多关于使用核心动画来实现动画的相关信息，参见“核心动画编程指南”。

# 视图和窗口架构
视图和窗口展示了你的应用程序的用户界面并且处理该用户界面的交互。UIKit以及其他的系统类库提供了大量的视图让你直接或做出很少的修改便能使用。在你需要展现和标准视图不太一样的内容的地方，你还可以定义自己的视图。  
无论你是使用系统的视图或者创建你自己的自定义视图，你都需要理解UIView和UIWindow类提供的基本结构。这些类提供了复杂的工具来管理布局以及视图的展示。了解这些设备的工作方式对于确保您的视图在应用程序中发生更改时具有适当的行为非常重要。
## 视图架构基本原理
大部分你想做的可视化工作都与视图对象有关——它是UIView类的实例对象。视图对象定义了屏幕上的一块矩形区域，它负责处理该矩形区域的绘制和触摸事件。视图还可以做为其他视图的父视图，调整子视图的位置和大小。大部分视图之间的关系UIView类都已经处理好了，不过你也可以根据需要定制默认的行为。  
视图与核心动画层一起负责处理视图内容的渲染和动画。UIKit中的每个视图都是基于一个层对象（通常是CALayer类的实例对象）的，它负责视图的存储，处理视图相关的动画。大部分你需要的操作都可以通过UIView提供的接口来执行。不过，如果你想更好的控制视图的渲染和动画，你可以通过它的layer对象来执行。  
为了更好的理解视图和层的关系，让我们来看一个例子。图1-1展示了视图架构与其底层的核心动画层对象之间的关系（示例来自 ViewTransitions 示例代码）。应用程序中的视图包含一个窗口（也是个视图），一个通用的UIView对象作为容器视图，一个图片视图，一个工具栏来展示按钮，以及一个bar按钮（它本身不是一个视图，但其内部管理者一个视图）。（实际上ViewTransitions 示例代码包含了一个额外的图片视图用来实现转场动画，为了简单起见，也由于该视图通常是隐藏的，就不包含在图1-1中了）每个视图都有一个相关的层对象，可以通过视图的layer属性来进行访问。（由于bar按钮不是一个视图，你不能够直接访问它的层对象。）在这些层对象背后是核心动画负责渲染对象，最后是用于管理屏幕上的实际位的硬件缓冲区。  

图1-1 一个简单应用程序的视图架构  
![](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/view-layer-store.jpg)  

核心动画层的使用对于性能有着极为重要的影响。对于一个视图对象的实际绘制的代码要尽可能少的调用，一旦代码被调用，其结果会被核心动画所缓存下来，随后会尽可能的复用。重用已渲染过的内容将减少更新视图时通常需要消耗的代价昂贵的绘图周期。在动画期间重用这些内容尤为重要，在此期间已经存在的内容是能够被改变的。这样重用将会比创建新的内容消耗更少的资源。
### 视图层级和子视图的管理
除了提供它本身的内容之外，一个视图还能够担任其它视图的容器功能。当一个视图包含了另一个视图的时候，一个父子关系就在这两个视图之间形成了。子视图在这个关系中被称作“subview”，父视图被称作“superview”。创建这种类型的关系对应用程序的可视外观和应用程序的行为都有影响。  
在表现上，子视图会遮盖全部或者部分其父视图的内容。若子视图完全不透明，那么被子视图占据的那部分区域会完全阻止了那部分区域的父视图的响应。若子视图是部分透明的，那么在显示到屏幕之前，两个视图的这一部分内容将会融合在一起。每个父视图都以有序的形式存储其子视图，这个顺序也会影响每个子视图的显示。若两个兄弟视图有重叠的部分，那么最后被添加的那个视图（或被移动到子视图数组末尾的那个视图）将会显示在最上层。  
父子视图之间的这个关系同样会影响几个视图的行为。改变父视图的尺寸会引起连锁反应，这将导致它的子视图的大小和位置的改变。当你改变一个父视图的大小时，你可以适时的调整子视图的大小。其它会引起子视图改变的行为包括：隐藏其父视图，改变父视图的alpha值（透明度）或将一个数学上的转换应用到父视图的坐标系当中。  
视图层级当中视图的结构安排同样影响了你的应用程序如何响应事件的行为。当触摸事件发生在一个特定的视图上时，系统会发送一个携带触摸信息的事件对象给那个视图以便其对其做出响应。不过，若该视图不处理这一触摸事件的话，它可以将事件对象传递给其父视图。若父视图也不处理该事件的话，它还可以继续传递给其父视图，以此类推沿着响应链条传递。特定的视图还可以将事件对象传递给一个响应对象中介，比如视图控制器。若没有对象来接收事件的话，最终会抵达应用程序对象，通常会被忽视处理。  
更多关于如何创建视图层级的相关信息，参见“创建和管理一个视图层级”。
### 视图绘制循环
在展现内容的时候，UIView类使用的是一种请求式的绘制模型。当视图第一次呈现在屏幕上时，系统会要求它来绘制内容。然后系统会捕获它的内容的一个截图作为视图的展示内容。若你永远不改变该视图的内容的话，视图的绘制代码将永远不会被再次调用。截图的图片将会在涉及到视图的操作当中被反复使用。若你改变内容，你应当通知系统视图内容发生了变更。视图将会重复绘制视图的过程，然后将捕获新的结果的截图。  
当你的视图内容改变的时候，你不应该直接重新绘制这些变更。你应该使用 setNeedsDisplay 或 setNeedsDisplayInRect: 方法来使这些视图无效。这些方法会通知系统这些视图的内容已经发生了变更，它需要在下一个合适的时机进行重绘。系统将等待到当前运行循环的末尾, 然后再启动任何绘图操作。此延迟使您有机会使多个视图无效、添加或删除层次结构中的视图、隐藏视图、调整视图大小和重新定位视图。所有你做出的改变都会在随后的同一时间同时反映出来。  

```
注意：改变视图的几何形状不会自动触发系统重绘视图内容。视图的 contentMode 属性决定了视图的几何尺寸如何变更才会被解释执行。大部分内容模式会在当前视图的区域内拉伸或重新布局已经存在的截图而不是重新创建一个新的。更多关于内容模式如何影响你的视图绘制过程的相关信息，参见“内容模式”。
```

当渲染你的视图内容的时机到来时，实际上的绘制过程的改变依赖于视图本身和它的配置。系统通常会使用自己的方法来渲染该内容。但系统也暴露了接口让你来配置视图的实际展现形式。对于自定义的UIView的子类而言，你可以通过重写视图的 drawRect: 方法来绘制你的视图的内容。还有很多种其它的方式来提供视图的内容，比如直接设置底层的layer层，但重写 drawRect: 方法是经常使用的一种方式。  
更多关于如何绘制自定义视图内容的相关信息，参见“实现你的绘制代码”。
### 内容模式
每个视图都拥有一个内容模式，它负责控制如何回收视图的内容来响应视图在形状上的变化以及是否回收视图的内容。当视图第一次被展示的时候，它通常会渲染器内容，渲染的结果将会被底层位图所捕获。在这之后，改变视图的结构并不总是引起位图重新创建。属性 contentMode 的值决定了位图是否需要被放大来适应新的大小或者简单的将一个角或一个边固定住。  
当你做以下操作的时候，一个视图的内容模式将会被应用：  

* 改变矩形视图的 frame 或 bounds 属性的宽高。
* 将含有一个放大因素的转换属性赋值给视图的 transform 属性。

默认的，大部分视图的 contentMode 属性被设置为 UIViewContentModeScaleToFill，这将引起视图的内容被放大来适应新的尺寸。图1-2展示了某些可用的视图模式发生时的结果。如你在图中所见，不是所有的内容模式的结果都会在视图的边界内被全部填充，这将可能会扭曲视图内容。  

图1-2 内容模式对比  

![](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/scale_aspect.jpg)

内容模式对于回收视图的内容而言是好事，但当你指定你的自定义视图在放大或改变大小等操作时也可以设置内容模式为 UIViewContentModeRedraw。将视图的内容模式设置为该值将强制系统调用视图的 drawRect: 方法来响应形状的变更。通常来讲，你应当尽可能尽量避免使用该值，尤其是在使用标准的系统视图时。  
更多关于内容模式的可用信息，参见“视图类参考文献”。
### 拉伸视图
你可以指定视图的一部分是可拉伸的，当视图的大小改变的时候，只有可拉伸部分的内容才会响应。通常在按钮或其它的定义了可重用区域的视图中应用拉伸模式。你指定的拉伸区域可以允许视图的两个轴方向拉伸。当然，当在两个轴方向拉伸视图的时候，视图的边界必须定义好可重用的部分来避免任何的扭曲。图1-3展示了这种扭曲是如何显示的。视图中带颜色的部分的原始像素被复制, 以填充较大视图中的相应区域。  

图1-3 拉伸一个按钮的背景  

![](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/button_scale.jpg)  

你可以使用 contentStretch 属性来指定一个视图的可拉伸区域。该属性接收一个0.0到1.0的矩形值。当拉伸视图的时候，系统将该值域当前视图的大小和放大因素相乘来决定哪个像素或像素点需要被拉伸。该值的应用减少了每次视图尺寸变更的时候都需要更新contentStretch的情况。  
视图的内容模式同样在决定视图的哪部分被拉伸的应用中扮演了角色。拉伸的区域只有在内容模式引起视图的内容被放大的时候才会被应用到。这意味着拉伸视图仅在 UIViewContentModeScaleToFill，UIViewContentModeScaleAspectFit，和 UIViewContentModeScaleAspectFill 等内容模式中才支持。若你指定一个将内容的一个边或一个角固定的内容模式（并没有实际放大内容），视图将忽略拉伸区域。  

	注意：在创建一个可拉伸的UIImage对象来作为指定视图的背景图的时候，推荐使用contentStretch属性。可拉伸视图被核心动画层所管理，通常这将提供更好的性能。

### 内置的动画支持
在每个视图背后都有一个layer对象，它的好处就是你可以很容易的对很多视图相关的变化进行动画展示。动画是一种很有效的和用户互动的方式，在设计你的应用程序期间应当被考虑。很多UIView类的属性都是可以动画的——意思是对于从一个值到另一个值的动画是半自动支持的。要执行一个可动画展示的属性，你只需要做到以下两点：  

1. 告诉UIKit你需要执行一个动画。
2. 改变该属性的值。

UIView当中你可以动画展示的属性如下：  

frame——用它来动画展示视图的位置和大小变更  
bounds——用它来动画展示视图的大小变更  
center——用它来动画展示视图的位置  
transform——用它来旋转或放大视图  
alpha——用它来改变视图的透明度  
backgroundColor——用它来改变视图的背景色  
contentStretch——用它来改变视图的可拉伸区域的变更  

当从一组视图转换到另一组视图的时候，动画效果的应用很重要。通常使用一个视图控制器来管理相关的用户界面上的动画转换。举例来说，对于包含从高层到低层信息的导航界面而言，通常使用导航控制器来管理显示每个相关数据层级的界面转换。不过，你也可以创建两组视图的转换动画来替代视图控制器。在标准的视图控制器动画无法达到你的要求的时候，你就可以这么做。  
出了利用UIKit类来创建动画，你还可以使用核心动画层来创建动画。到了layer层这一级别，你将可以更好的控制你的动画的时机和属性。  
有关如何执行基于视图的动画的详情，参见“动画”一章。有关使用核心动画来创建动画的相关信息，参见“核心动画编程指南”和“核心动画手册”。  
## 视图坐标系统
UIKit中的默认的坐标系统是左上角为坐标原点，然后从坐标原点向下和向右。坐标值使用浮点型，这能够对内容进行复杂的布局和位置计算而不用管底层的屏幕分辨率。图1-4展示了屏幕相关的坐标系统。除了屏幕坐标系统，窗口和视图也定义了它们自己的坐标系统来让你能够设定视图或窗口的坐标（而无需关心屏幕的坐标系统）。  

图1-4 UIKit中的坐标系统方向  

![](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/native_coordinate_system.jpg)  

由于每个视图和窗口都定义了它自己的坐标系统，那么你就需要在任何时候都要知道到底是哪个坐标系统在起作用。每当你绘制内容到一个视图，或改变其形状的时候，这都关系到某个坐标系统。在绘制时，你设定的是视图本身的坐标系统。在改变形状时，你设定的是父视图的坐标系统。UIWindow 和 UIView 都包含了方法来帮助你从一个坐标系统转换到另一个。  

> 重要：某些iOS技术定义了与UIKit不同的坐标原点和方向的坐标系统。比如Core Graphics 和 OpenGL ES 使用的是左下角为坐标原点，y轴沿屏幕方向向上的坐标系统。在绘制或创建内容的时候，你写的代码必须考虑到这一点，并应当根据需要对坐标值（或坐标系统的方向）进行调整。

### frame，bounds和center等属性之间的关系
一个视图对象通过使用frame，bounds，和 center等属性来确定其尺寸和位置。  

* frame属性包含frame 矩形区域，它指定了一个视图在其父视图坐标系统中的位置和大小。
* bounds属性包含bounds矩形区域，它指定了一个视图在其本身的坐标系统中的大小（以及其内容的位置）。
* center属性包含了视图中心点，它表示视图在其父视图坐标系统的中心点。

通常使用frame和bounds属性来调整当前视图的几何结构。比如，当你构建视图的层级或者在运行时改变一个视图的尺寸和位置时，你应该使用这些属性。若你只改变视图的位置（而非其尺寸）的话，center属性就可以做到这一点。center属性中的值始终有效，即使是视图的转换中加入了放大或旋转元素。而frame属性中的值在这时就不一定有效了，在视图的转换与转换ID不同的时候，它的值就是无效的。  
通常在绘制的过程中使用bounds属性。bounds矩形区域表示视图在其本身坐标系统中。默认的坐标原点是 (0, 0) ，它的尺寸与frame矩形区域大小相同。任何你在这个区域中绘制的内容都是视图可视化内容的一部分。若你改变了bounds矩形区域的原点的话，任何你绘制在新矩形区域中的内容都会作为视图可视化区域的一部分。  
图1-5 展示了一个image视图的frame 和 bounds之间的关系。在图中，左上角的image视图在其父视图坐标系统中的 (40, 40) 点，尺寸为240乘以380。对于bounds矩形区域，坐标原点为 (0, 0) 矩形区域的大小同样是240乘以380。  

图1-5 视图的frame 和 bounds之间的关系 
![](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/frame_bounds_rects.jpg)  

尽管你能够不依赖其他的属性就能够改变frame，bounds，和 center，但改变一个属性将会以以下方式影响其他属性：  

* 当你设置frame属性的时候，bounds属性的值将会等于新frame举行区域的值。center属性的值同样会改变成新frame矩形区域的中心点的值。
* 当你设置center属性的时候，frame的坐标原点也会响应的做出改变。  
* 当你设置bounds属性的大小，frame属性的大小的值也会被设置为bounds矩形区域的大小。

默认的，一个视图的frame不会被其父视图的frame截去。因此，任何在其父视图frame之外的子视图都会被完全的渲染。不过，你可以通过设置父视图的 clipsToBounds 属性为YES来改变这一行为。不论子视图的是否被截取，触摸事件都会遵守目标视图的父视图的bounds矩形区域。换句话说，若父视图bounds矩形区域之外的部分发生了触摸事件，那么该区域的视图将不会获取到触摸事件。
### 坐标系统的转换
坐标系统转换为快速且简单的改变你的视图（或其内容）提供了一种方式。“仿射变换”是一种数学上的矩阵，它指的是一个坐标点在一个坐标系统中如何映射到另一个不同的坐标系统的一个坐标点上。你可以将仿射变换应用到你的整个视图上，来改变尺寸、位置或者相对于其父视图的方向。您还可以在绘制视图的代码中使用仿射变换来对呈现内容的单个片断执行相同类型的操作。因此你如何应用仿射变换取决于上下文：  

* 若想修改你的整个视图，修改视图的transform属性中的仿射变换。
* 若想修改你的视图中的一部分内容，在drawRect: 方法中修改与当前图形上下文相关的仿射变换。

通常在实现动画的时候，修改一个视图的transform属性。举例来说，你可以使用该属性来创建一个你的视图沿其中心旋转的动画。不要使用该属性来作为你的视图的永久变化，比如修改其在父视图中的位置或尺寸。对于这种变更，你应当修改视图的frame属性。  

> 注意：当改变视图的transform属性时，所有转换都是相对于视图的中心点执行的。

在视图的 drawRect: 方法中，可以将仿射变换应用在你想要绘制的位置和方向上。你无需调整你的视图上的某个对象的位置，只需要简单的为每个对象创建一个相关的调整坐标，通常是（0，0），然后在绘制之前将transform应用在该对象的位置即可。这样做的话，若对象在你的视图当中的位置改变的话，你只需修改transform，这样做比在其位置重新创建对象更快并且消耗更少。你可以使用 CGContextGetCTM 函数来重新获取与图形上下文相关的仿射变换，并且可以使用相关的核心图形层函数在绘制期间来设置或修改它的transform。  
“当前转换矩阵”（CTM）是在任何给定时间使用的仿射变换。当对你的整个视图的图形进行操作时，CTM将会影响存储在视图的transform属性中的值。在drawRect: 方法中，CTM是与当前图形上下文相关的仿射变换。  
每个子视图依据其父视图的坐标系统来构建自己的坐标系统。所以当你修改视图的transform属性时，该属性的变化将会影响视图本身和其所有的子视图。不过，这些变化只影响最终视图渲染到屏幕上的效果。由于每个视图只在其自己的边界内绘制其内容和布局子视图，那么在绘制和布局的时候就可以忽略其父视图的transform。  
图1-6 展示了两种不同的旋转变换在渲染过程中合并后的效果。在视图的 drawRect: 方法中，将一个45度旋转应用在一个图形上将导致该图形旋转45度。将另一个45度旋转应用到视图上将导致图形旋转了90度。图形相对于其视图依旧旋转了45度，但视图的旋转导致它旋转的更多了。  

图1-6 旋转视图和其本身的内容  
![](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/xform_rotations.jpg) 

> 重要：若视图的transform属性与转换不统一，那么该视图的frame属性的值是未定义并且必须被忽略的。将一个transform应用在一个视图上时，必须使用视图的bounds 和 center属性来获取该视图的尺寸和位置。其任意子视图的frame依旧有效，因为它们是与视图的bounds相关的。

更多关于在运行时修改视图的transform属性的相关信息，参见“转换、放大和旋转视图”。更多关于如何在绘制期间使用transforms来定位内容的相关信息，参见“iOS绘制和打印指南”。
### 点与像素
iOS 中，所有的坐标值以及距离都使用浮点值以一种叫做points（点）的单位来设定。点的可测量的大小从设备到设备是不同的, 很大程度上无关紧要。对点的理解主要是它们为绘图提供了一个固定的参照框架。  
列表1-1 列出了竖直方向基于iOS设备的不同类型的屏幕尺寸（以点为测量单位）。宽度在前，后面是屏幕的高度。只要您将界面设计成这些屏幕大小, 您的视图就会正确显示在相应类型的设备上。  

列表1-1 基于iOS设备的屏幕尺寸  

设备  | 屏幕尺寸（以点为单位）
------------- | -------------
四英寸高清屏幕的iPhone和iPod touch设备  | 320 x 568
其他iPhone和iPod touch设备  | 320 x 480
iPad  | 768 x 1024

基于点的计量系统被各种类型的设备所使用，被称作“用户坐标空间”。这种标准坐标空间几乎可以在你的代码中的所有位置使用。举例来说，当调整一个视图的几何结构或调用核心绘画函数来绘制视图的内容时，你就可以使用点和用户坐标空间。尽管在用户坐标空间上的坐标有时可以直接映射到设备屏幕的像素点，但你应当不要假设这种情况的存在。而应该记住以下内容：  

*一个点没有必要对应屏幕上的一个像素*  

在设备层面，所有你在视图中设置的坐标都必须被转换为像素。不过，从用户坐标空间的点到设备坐标空间的像素的转换通常被系统处理了。UIKit 和 Core Graphics 底层都使用了基于矢量的绘图模型，在这里所有的坐标值都被使用点来设定。因此，若你使用Core Graphics 来绘制曲线的话，你应当使用相同的值来设置曲线，而无需关心底层屏幕的分辨率。  
当你需要处理图片或其他的基于像素的技术（比如OpenGL ES），iOS将为管理这些像素提供帮助。对于作为资源存储在你的应用程序包当中的静态图片文件，iOS为设置你的图片为不同的像素密度定义了各种转换，也处理了将图片加载为最符合当前屏幕分辨率。视图也为当前的放大因素提供了相关信息，所以你就可以手动调整任何基于像素的绘制代码来适应高分辨率的屏幕。在“iOS绘图和打印指南”一文中的“在视图中支持高分辨率的屏幕”一章中介绍了在不同屏幕分辨率上处理基于像素内容的相关技术内容。
## 运行时视图交互模型

## 高效使用视图的建议

### 视图不总是有相关的视图控制器

### 最小化自定义绘制

### 利用内容模式

### 尽可能将视图声明为不透明的

### 当滚动的时候调整你的视图的绘制行为

### 不要通过嵌入子视图来进行自定义控制

# 窗口

## 包含窗口的任务

## 创建和配置一个窗口

### 在界面编辑器中创建窗口

### 以编码方式创建窗口

### 添加内容到你的窗口

### 更改窗口的等级

## 监控窗口的变更

## 在外部设备展示内容

### 处理屏幕的连接和断开连接的通知

### 为外部设备配置一个窗口

### 为外部展示配置屏幕模式

# 视图

## 创建和配置视图对象

### 使用界面编辑器来创建视图对象

### 编码创建视图对象

### 设定一个视图的属性

### 为视图设置将来要使用的标签

## 创建和管理视图层级

### 添加和移除子视图

### 隐藏视图

### 在视图层级中定位视图

### 转场，放大和旋转视图

### 在视图层级中转换坐标

## 在运行时调整视图的大小和位置

### 为布局的变更做好准备

### 使用自动布局的规则来自动的处理布局的变更

### 手动对你的视图布局进行调整

## 在运行时修改视图

## 与核心动画层的交互

### 改变一个视图的层级类

### 在一个视图中嵌入层级对象

## 声明一个自定义视图

### 实现一个自定义视图的检查表

### 初始化你的自定义视图

### 实现你的绘制代码

### 响应事件

### 为你的视图进行清理

# 动画

## 什么能够被动画展示？

## 一个视图中的动画属性变更

### 使用基于块的方法来开始动画

### 使用开始／提交的方法来开始动画

#### 为开始／提交动画配置参数

#### 配置动画代理

### 嵌套动画块

### 实现回调动画本身

## 在视图转场之间创建动画

### 改变一个视图的子视图

### 替换一个视图为不同的视图

## 链接多个动画

## 动画改变视图和层的变更