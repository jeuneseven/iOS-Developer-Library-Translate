[View Programming Guide for iOS 原文链接](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503)

# 介绍
## 关于窗口和视图
在iOS当中，你可以使用窗口和视图来展示你的应用程序的内容到屏幕上。窗口本身没有任何可视化的内容，但它为你的应用程序的视图提供了一个基本的容器。视图可以定义窗口的一部分用来填充你想填充的内容。举例来说，你可以使用视图来展示图片、文字、图形或者任何它们之间的组合。你还可以使用视图来组织管理其它的视图。
### 概览
每款应用程序都至少含有一个窗口和一个视图来展现内容。UIKit和其它的系统框架都提供了定义好的视图让你用来展示你的内容。这些视图从简单的按钮、标签到复杂的视图，比如列表、选择器以及滚动视图应有尽有。若定义好的视图没有提供你想要的功能的话，你还可以定义自定义的视图来管理绘制贺事件处理。
#### 视图管理着你的应用程序的可视化界面
视图是UIView类（或其子类）的实例对象，它在你的应用程序的窗口中管理着一个矩形区域。视图负责绘制内容，处理多点触摸事件以及管理子视图的布局。绘制包括使用核心制图、OpenGL ES、或者UIKit等制图技术来在一个视图的矩形区域绘制图形，图片以及文字。一个视图负责在其矩形区域中使用手势或者直接处理触摸事件。在视图层级中，父视图负责对其子视图进行动态的设置位置和大小。这种能够动态的修饰子视图的能力让你的视图能够根据情况进行调整，比如屏幕旋转和动画。  
你可以将视图视作构建你的视图界面的模块。通常使用多个视图来构建视图层级而不是只用一个来展示所有你的内容。每个视图层级中的视图都展示了你的视图界面中的一个特别的部分，它通常已经作为一种特殊类型的内容优化过了。举例来说，UIKit为展示图片，文字和其它类型的内容都有着指定的视图类型。  

```
相关章节：视图和窗口架构，视图
```
#### 窗口协调展示你的视图
窗口是UIWindow类的实例对象，它处理了你的应用程序用户界面的所有展示内容。窗口和视图（以及持有它的视图控制器）一起管理用户交互，响应变更以及视图的可视化层级。大部分情况下，你的窗口不需要做出任何改变。一旦窗口被创建，它将保持不变，只有它所显示的视图才会更改。每个应用程序至少含有一个窗口来展示应用程序的用户界面到设备的主屏幕上。如果有额外的展示设备被连接到设备上，应用程序也可以创建第二个窗口来将内容展示到该屏幕上。

```
相关章节：窗口
```
#### 动画对界面的改变为用户提供了可视化的反馈
动画为用户提供了视图层级变更的可视化反馈。系统为模态化展示视图和一组不同视图之间的转换定义了标准动画。不过，视图的多个属性都能够被直接动画展示。举例来说，通过动画你可以改变一个视图的透明度，它在屏幕上的位置，它的尺寸，它的背景颜色或者其它的属性。若你直接作用于视图底层的核心动画层对象的话，你还可以执行更多的动画。
```
相关章节：动画
```
#### 界面编辑器的作用
界面编辑器是一款你可以用来生动的构建和配置你的应用程序的窗口和视图的应用程序。使用界面编辑器你能够将你的视图汇集到一起，将其放置在一个nib文件当中，后者是存储你的视图和其它对象的静态版本的一种资源文件。当你在运行时加载一个nib文件的时候，它当中的对象将会重新组合成实际的对象，你的代码就能够以编码的方式对其进行操作了。  
界面编辑器大大简化了你在创建应用程序用户界面时的操作。由于iOS对于界面编辑器和nib文件的支持是贯穿始终的，你在你的应用程序设计期间只需要做很少的工作就能够将nib文件结合进去。  
更多关于如何使用界面编辑器的相关信息参见“界面编辑器用户指南”。关于视图控制器如何管理在nib文件中包含的视图，参见“iOS视图控制器编程指南”中的“创建自定义内容的视图控制器”一节。
### 另请参见
由于视图是很复杂和灵活的一种对象，不可能在一篇文档中涵盖所有它的内容。不过，以下有几篇其它的文档能够帮助你整体学习视图管理和用户界面的其它方面。  

* 视图控制器在管理你的应用程序的视图中是很重要的一部分。视图控制器在单个视图层次结构中主持所有视图并帮助这些视图展示到屏幕上。更多关于视图控制器以及它所扮演的角色，参见“iOS视图控制器编程指南”。
* 在你的应用程序中，视图扮演者手势和触摸事件的关键接受者角色。更多关于适用手势和直接处理触摸事件的相关信息，参见“iOS事件处理指南”。
* 自定义视图必须使用相应的绘图技术来渲染它的内容。更多如何使用这些技术来绘制你自己的视图的相关信息，参见“iOS绘图和印刷指南”。
* 在标准视图动画无法满足需求的地方，你可以使用核心动画。更多关于使用核心动画来实现动画的相关信息，参见“核心动画编程指南”。

# 视图和窗口架构
视图和窗口展示了你的应用程序的用户界面并且处理该用户界面的交互。UIKit以及其他的系统类库提供了大量的视图让你直接或做出很少的修改便能使用。在你需要展现和标准视图不太一样的内容的地方，你还可以定义自己的视图。  
无论你是使用系统的视图或者创建你自己的自定义视图，你都需要理解UIView和UIWindow类提供的基本结构。这些类提供了复杂的工具来管理布局以及视图的展示。了解这些设备的工作方式对于确保您的视图在应用程序中发生更改时具有适当的行为非常重要。
## 视图架构基本原理
大部分你想做的可视化工作都与视图对象有关——它是UIView类的实例对象。视图对象定义了屏幕上的一块矩形区域，它负责处理该矩形区域的绘制和触摸事件。视图还可以做为其他视图的父视图，调整子视图的位置和大小。大部分视图之间的关系UIView类都已经处理好了，不过你也可以根据需要定制默认的行为。  
视图与核心动画层一起负责处理视图内容的渲染和动画。UIKit中的每个视图都是基于一个层对象（通常是CALayer类的实例对象）的，它负责视图的存储，处理视图相关的动画。大部分你需要的操作都可以通过UIView提供的接口来执行。不过，如果你想更好的控制视图的渲染和动画，你可以通过它的layer对象来执行。  
为了更好的理解视图和层的关系，让我们来看一个例子。图1-1展示了视图架构与其底层的核心动画层对象之间的关系（示例来自 ViewTransitions 示例代码）。应用程序中的视图包含一个窗口（也是个视图），一个通用的UIView对象作为容器视图，一个图片视图，一个工具栏来展示按钮，以及一个bar按钮（它本身不是一个视图，但其内部管理者一个视图）。（实际上ViewTransitions 示例代码包含了一个额外的图片视图用来实现转场动画，为了简单起见，也由于该视图通常是隐藏的，就不包含在图1-1中了）每个视图都有一个相关的层对象，可以通过视图的layer属性来进行访问。（由于bar按钮不是一个视图，你不能够直接访问它的层对象。）在这些层对象背后是核心动画负责渲染对象，最后是用于管理屏幕上的实际位的硬件缓冲区。  

图1-1 一个简单应用程序的视图架构  
![](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/view-layer-store.jpg)  

核心动画层的使用对于性能有着极为重要的影响。对于一个视图对象的实际绘制的代码要尽可能少的调用，一旦代码被调用，其结果会被核心动画所缓存下来，随后会尽可能的复用。重用已渲染过的内容将减少更新视图时通常需要消耗的代价昂贵的绘图周期。在动画期间重用这些内容尤为重要，在此期间已经存在的内容是能够被改变的。这样重用将会比创建新的内容消耗更少的资源。
### 视图层级和子视图的管理
除了提供它本身的内容之外，一个视图还能够担任其它视图的容器功能。当一个视图包含了另一个视图的时候，一个父子关系就在这两个视图之间形成了。子视图在这个关系中被称作“subview”，父视图被称作“superview”。创建这种类型的关系对应用程序的可视外观和应用程序的行为都有影响。  
在表现上，子视图会遮盖全部或者部分其父视图的内容。若子视图完全不透明，那么被子视图占据的那部分区域会完全阻止了那部分区域的父视图的响应。若子视图是部分透明的，那么在显示到屏幕之前，两个视图的这一部分内容将会融合在一起。每个父视图都以有序的形式存储其子视图，这个顺序也会影响每个子视图的显示。若两个兄弟视图有重叠的部分，那么最后被添加的那个视图（或被移动到子视图数组末尾的那个视图）将会显示在最上层。  
父子视图之间的这个关系同样会影响几个视图的行为。改变父视图的尺寸会引起连锁反应，这将导致它的子视图的大小和位置的改变。当你改变一个父视图的大小时，你可以适时的调整子视图的大小。其它会引起子视图改变的行为包括：隐藏其父视图，改变父视图的alpha值（透明度）或将一个数学上的转换应用到父视图的坐标系当中。  
视图层级当中视图的结构安排同样影响了你的应用程序如何响应事件的行为。当触摸事件发生在一个特定的视图上时，系统会发送一个携带触摸信息的事件对象给那个视图以便其对其做出响应。不过，若该视图不处理这一触摸事件的话，它可以将事件对象传递给其父视图。若父视图也不处理该事件的话，它还可以继续传递给其父视图，以此类推沿着响应链条传递。特定的视图还可以将事件对象传递给一个响应对象中介，比如视图控制器。若没有对象来接收事件的话，最终会抵达应用程序对象，通常会被忽视处理。  
更多关于如何创建视图层级的相关信息，参见“创建和管理一个视图层级”。
### 视图绘制循环
在展现内容的时候，UIView类使用的是一种请求式的绘制模型。当视图第一次呈现在屏幕上时，系统会要求它来绘制内容。然后系统会捕获它的内容的一个截图作为视图的展示内容。若你永远不改变该视图的内容的话，视图的绘制代码将永远不会被再次调用。截图的图片将会在涉及到视图的操作当中被反复使用。若你改变内容，你应当通知系统视图内容发生了变更。视图将会重复绘制视图的过程，然后将捕获新的结果的截图。  
当你的视图内容改变的时候，你不应该直接重新绘制这些变更。你应该使用 setNeedsDisplay 或 setNeedsDisplayInRect: 方法来使这些视图无效。这些方法会通知系统这些视图的内容已经发生了变更，它需要在下一个合适的时机进行重绘。系统将等待到当前运行循环的末尾, 然后再启动任何绘图操作。此延迟使您有机会使多个视图无效、添加或删除层次结构中的视图、隐藏视图、调整视图大小和重新定位视图。所有你做出的改变都会在随后的同一时间同时反映出来。  

```
注意：改变视图的几何形状不会自动触发系统重绘视图内容。视图的 contentMode 属性决定了视图的几何尺寸如何变更才会被解释执行。大部分内容模式会在当前视图的区域内拉伸或重新布局已经存在的截图而不是重新创建一个新的。更多关于内容模式如何影响你的视图绘制过程的相关信息，参见“内容模式”。
```

当渲染你的视图内容的时机到来时，实际上的绘制过程的改变依赖于视图本身和它的配置。系统通常会使用自己的方法来渲染该内容。但系统也暴露了接口让你来配置视图的实际展现形式。对于自定义的UIView的子类而言，你可以通过重写视图的 drawRect: 方法来绘制你的视图的内容。还有很多种其它的方式来提供视图的内容，比如直接设置底层的layer层，但重写 drawRect: 方法是经常使用的一种方式。  
更多关于如何绘制自定义视图内容的相关信息，参见“实现你的绘制代码”。
### 内容模式
每个视图都拥有一个内容模式，它负责控制如何回收视图的内容来响应视图在形状上的变化以及是否回收视图的内容。当视图第一次被展示的时候，它通常会渲染器内容，渲染的结果将会被底层位图所捕获。在这之后，改变视图的结构并不总是引起位图重新创建。属性 contentMode 的值决定了位图是否需要被放大来适应新的大小或者简单的将一个角或一个边固定住。  
当你做以下操作的时候，一个视图的内容模式将会被应用：  

* 改变矩形视图的 frame 或 bounds 属性的宽高。
* 将含有一个放大因素的转换属性赋值给视图的 transform 属性。

默认的，大部分视图的 contentMode 属性被设置为 UIViewContentModeScaleToFill，这将引起视图的内容被放大来适应新的尺寸。图1-2展示了某些可用的视图模式发生时的结果。如你在图中所见，不是所有的内容模式的结果都会在视图的边界内被全部填充，这将可能会扭曲视图内容。  

图1-2 内容模式对比  

![](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/scale_aspect.jpg)

内容模式对于回收视图的内容而言是好事，但当你指定你的自定义视图在放大或改变大小等操作时也可以设置内容模式为 UIViewContentModeRedraw。将视图的内容模式设置为该值将强制系统调用视图的 drawRect: 方法来响应形状的变更。通常来讲，你应当尽可能尽量避免使用该值，尤其是在使用标准的系统视图时。  
更多关于内容模式的可用信息，参见“视图类参考文献”。
### 拉伸视图
你可以指定视图的一部分是可拉伸的，当视图的大小改变的时候，只有可拉伸部分的内容才会响应。通常在按钮或其它的定义了可重用区域的视图中应用拉伸模式。你指定的拉伸区域可以允许视图的两个轴方向拉伸。当然，当在两个轴方向拉伸视图的时候，视图的边界必须定义好可重用的部分来避免任何的扭曲。图1-3展示了这种扭曲是如何显示的。视图中带颜色的部分的原始像素被复制, 以填充较大视图中的相应区域。  

图1-3 拉伸一个按钮的背景  

![](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/button_scale.jpg)  

你可以使用 contentStretch 属性来指定一个视图的可拉伸区域。该属性接收一个0.0到1.0的矩形值。当拉伸视图的时候，系统将该值域当前视图的大小和放大因素相乘来决定哪个像素或像素点需要被拉伸。该值的应用减少了每次视图尺寸变更的时候都需要更新contentStretch的情况。  
视图的内容模式同样在决定视图的哪部分被拉伸的应用中扮演了角色。拉伸的区域只有在内容模式引起视图的内容被放大的时候才会被应用到。这意味着拉伸视图仅在 UIViewContentModeScaleToFill，UIViewContentModeScaleAspectFit，和 UIViewContentModeScaleAspectFill 等内容模式中才支持。若你指定一个将内容的一个边或一个角固定的内容模式（并没有实际放大内容），视图将忽略拉伸区域。  

	注意：在创建一个可拉伸的UIImage对象来作为指定视图的背景图的时候，推荐使用contentStretch属性。可拉伸视图被核心动画层所管理，通常这将提供更好的性能。

### 内置的动画支持
在每个视图背后都有一个layer对象，它的好处就是你可以很容易的对很多视图相关的变化进行动画展示。动画是一种很有效的和用户互动的方式，在设计你的应用程序期间应当被考虑。很多UIView类的属性都是可以动画的——意思是对于从一个值到另一个值的动画是半自动支持的。要执行一个可动画展示的属性，你只需要做到以下两点：  

1. 告诉UIKit你需要执行一个动画。
2. 改变该属性的值。

UIView当中你可以动画展示的属性如下：  

frame——用它来动画展示视图的位置和大小变更  
bounds——用它来动画展示视图的大小变更  
center——用它来动画展示视图的位置  
transform——用它来旋转或放大视图  
alpha——用它来改变视图的透明度  
backgroundColor——用它来改变视图的背景色  
contentStretch——用它来改变视图的可拉伸区域的变更  

当从一组视图转换到另一组视图的时候，动画效果的应用很重要。通常使用一个视图控制器来管理相关的用户界面上的动画转换。举例来说，对于包含从高层到低层信息的导航界面而言，通常使用导航控制器来管理显示每个相关数据层级的界面转换。不过，你也可以创建两组视图的转换动画来替代视图控制器。在标准的视图控制器动画无法达到你的要求的时候，你就可以这么做。  
出了利用UIKit类来创建动画，你还可以使用核心动画层来创建动画。到了layer层这一级别，你将可以更好的控制你的动画的时机和属性。  
有关如何执行基于视图的动画的详情，参见“动画”一章。有关使用核心动画来创建动画的相关信息，参见“核心动画编程指南”和“核心动画手册”。  
## 视图坐标系统
UIKit中的默认的坐标系统是左上角为坐标原点，然后从坐标原点向下和向右。坐标值使用浮点型，这能够对内容进行复杂的布局和位置计算而不用管底层的屏幕分辨率。图1-4展示了屏幕相关的坐标系统。除了屏幕坐标系统，窗口和视图也定义了它们自己的坐标系统来让你能够设定视图或窗口的坐标（而无需关心屏幕的坐标系统）。  

图1-4 UIKit中的坐标系统方向  

![](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/native_coordinate_system.jpg)  

由于每个视图和窗口都定义了它自己的坐标系统，那么你就需要在任何时候都要知道到底是哪个坐标系统在起作用。每当你绘制内容到一个视图，或改变其形状的时候，这都关系到某个坐标系统。在绘制时，你设定的是视图本身的坐标系统。在改变形状时，你设定的是父视图的坐标系统。UIWindow 和 UIView 都包含了方法来帮助你从一个坐标系统转换到另一个。  

> 重要：某些iOS技术定义了与UIKit不同的坐标原点和方向的坐标系统。比如Core Graphics 和 OpenGL ES 使用的是左下角为坐标原点，y轴沿屏幕方向向上的坐标系统。在绘制或创建内容的时候，你写的代码必须考虑到这一点，并应当根据需要对坐标值（或坐标系统的方向）进行调整。

### frame，bounds和center等属性之间的关系

### 坐标系统的转换

### 点与像素

## 运行时视图交互模型

## 高效使用视图的建议

### 视图不总是有相关的视图控制器

### 最小化自定义绘制

### 利用内容模式

### 尽可能将视图声明为不透明的

### 当滚动的时候调整你的视图的绘制行为

### 不要通过嵌入子视图来进行自定义控制

# 窗口

## 包含窗口的任务

## 创建和配置一个窗口

### 在界面编辑器中创建窗口

### 以编码方式创建窗口

### 添加内容到你的窗口

### 更改窗口的等级

## 监控窗口的变更

## 在外部设备展示内容

### 处理屏幕的连接和断开连接的通知

### 为外部设备配置一个窗口

### 为外部展示配置屏幕模式

# 视图

## 创建和配置视图对象

### 使用界面编辑器来创建视图对象

### 编码创建视图对象

### 设定一个视图的属性

### 为视图设置将来要使用的标签

## 创建和管理视图层级

### 添加和移除子视图

### 隐藏视图

### 在视图层级中定位视图

### 转场，放大和旋转视图

### 在视图层级中转换坐标

## 在运行时调整视图的大小和位置

### 为布局的变更做好准备

### 使用自动布局的规则来自动的处理布局的变更

### 手动对你的视图布局进行调整

## 在运行时修改视图

## 与核心动画层的交互

### 改变一个视图的层级类

### 在一个视图中嵌入层级对象

## 声明一个自定义视图

### 实现一个自定义视图的检查表

### 初始化你的自定义视图

### 实现你的绘制代码

### 响应事件

### 为你的视图进行清理

# 动画

## 什么能够被动画展示？

## 一个视图中的动画属性变更

### 使用基于块的方法来开始动画

### 使用开始／提交的方法来开始动画

#### 为开始／提交动画配置参数

#### 配置动画代理

### 嵌套动画块

### 实现回调动画本身

## 在视图转场之间创建动画

### 改变一个视图的子视图

### 替换一个视图为不同的视图

## 链接多个动画

## 动画改变视图和层的变更