[View Programming Guide for iOS 原文链接](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503)

# 介绍
## 关于窗口和视图
在iOS当中，你可以使用窗口和视图来展示你的应用程序的内容到屏幕上。窗口本身没有任何可视化的内容，但它为你的应用程序的视图提供了一个基本的容器。视图可以定义窗口的一部分用来填充你想填充的内容。举例来说，你可以使用视图来展示图片、文字、图形或者任何它们之间的组合。你还可以使用视图来组织管理其它的视图。
### 概览
每款应用程序都至少含有一个窗口和一个视图来展现内容。UIKit和其它的系统框架都提供了定义好的视图让你用来展示你的内容。这些视图从简单的按钮、标签到复杂的视图，比如列表、选择器以及滚动视图应有尽有。若定义好的视图没有提供你想要的功能的话，你还可以定义自定义的视图来管理绘制贺事件处理。
#### 视图管理着你的应用程序的可视化界面
视图是UIView类（或其子类）的实例对象，它在你的应用程序的窗口中管理着一个矩形区域。视图负责绘制内容，处理多点触摸事件以及管理子视图的布局。绘制包括使用核心制图、OpenGL ES、或者UIKit等制图技术来在一个视图的矩形区域绘制图形，图片以及文字。一个视图负责在其矩形区域中使用手势或者直接处理触摸事件。在视图层级中，父视图负责对其子视图进行动态的设置位置和大小。这种能够动态的修饰子视图的能力让你的视图能够根据情况进行调整，比如屏幕旋转和动画。  
你可以将视图视作构建你的视图界面的模块。通常使用多个视图来构建视图层级而不是只用一个来展示所有你的内容。每个视图层级中的视图都展示了你的视图界面中的一个特别的部分，它通常已经作为一种特殊类型的内容优化过了。举例来说，UIKit为展示图片，文字和其它类型的内容都有着指定的视图类型。  

```
相关章节：视图和窗口架构，视图
```
#### 窗口协调展示你的视图
窗口是UIWindow类的实例对象，它处理了你的应用程序用户界面的所有展示内容。窗口和视图（以及持有它的视图控制器）一起管理用户交互，响应变更以及视图的可视化层级。大部分情况下，你的窗口不需要做出任何改变。一旦窗口被创建，它将保持不变，只有它所显示的视图才会更改。每个应用程序至少含有一个窗口来展示应用程序的用户界面到设备的主屏幕上。如果有额外的展示设备被连接到设备上，应用程序也可以创建第二个窗口来将内容展示到该屏幕上。

```
相关章节：窗口
```
#### 动画对界面的改变为用户提供了可视化的反馈
动画为用户提供了视图层级变更的可视化反馈。系统为模态化展示视图和一组不同视图之间的转换定义了标准动画。不过，视图的多个属性都能够被直接动画展示。举例来说，通过动画你可以改变一个视图的透明度，它在屏幕上的位置，它的尺寸，它的背景颜色或者其它的属性。若你直接作用于视图底层的核心动画层对象的话，你还可以执行更多的动画。
```
相关章节：动画
```
#### 界面编辑器的作用
界面编辑器是一款你可以用来生动的构建和配置你的应用程序的窗口和视图的应用程序。使用界面编辑器你能够将你的视图汇集到一起，将其放置在一个nib文件当中，后者是存储你的视图和其它对象的静态版本的一种资源文件。当你在运行时加载一个nib文件的时候，它当中的对象将会重新组合成实际的对象，你的代码就能够以编码的方式对其进行操作了。  
界面编辑器大大简化了你在创建应用程序用户界面时的操作。由于iOS对于界面编辑器和nib文件的支持是贯穿始终的，你在你的应用程序设计期间只需要做很少的工作就能够将nib文件结合进去。  
更多关于如何使用界面编辑器的相关信息参见“界面编辑器用户指南”。关于视图控制器如何管理在nib文件中包含的视图，参见“iOS视图控制器编程指南”中的“创建自定义内容的视图控制器”一节。
### 另请参见
由于视图是很复杂和灵活的一种对象，不可能在一篇文档中涵盖所有它的内容。不过，以下有几篇其它的文档能够帮助你整体学习视图管理和用户界面的其它方面。  

* 视图控制器在管理你的应用程序的视图中是很重要的一部分。视图控制器在单个视图层次结构中主持所有视图并帮助这些视图展示到屏幕上。更多关于视图控制器以及它所扮演的角色，参见“iOS视图控制器编程指南”。
* 在你的应用程序中，视图扮演者手势和触摸事件的关键接受者角色。更多关于适用手势和直接处理触摸事件的相关信息，参见“iOS事件处理指南”。
* 自定义视图必须使用相应的绘图技术来渲染它的内容。更多如何使用这些技术来绘制你自己的视图的相关信息，参见“iOS绘图和印刷指南”。
* 在标准视图动画无法满足需求的地方，你可以使用核心动画。更多关于使用核心动画来实现动画的相关信息，参见“核心动画编程指南”。

# 视图和窗口架构
视图和窗口展示了你的应用程序的用户界面并且处理该用户界面的交互。UIKit以及其他的系统类库提供了大量的视图让你直接或做出很少的修改便能使用。在你需要展现和标准视图不太一样的内容的地方，你还可以定义自己的视图。  
无论你是使用系统的视图或者创建你自己的自定义视图，你都需要理解UIView和UIWindow类提供的基本结构。这些类提供了复杂的工具来管理布局以及视图的展示。了解这些设备的工作方式对于确保您的视图在应用程序中发生更改时具有适当的行为非常重要。
## 视图架构基本原理
大部分你想做的可视化工作都与视图对象有关——它是UIView类的实例对象。视图对象定义了屏幕上的一块矩形区域，它负责处理该矩形区域的绘制和触摸事件。视图还可以做为其他视图的父视图，调整子视图的位置和大小。大部分视图之间的关系UIView类都已经处理好了，不过你也可以根据需要定制默认的行为。  
视图与核心动画层一起负责处理视图内容的渲染和动画。UIKit中的每个视图都是基于一个层对象（通常是CALayer类的实例对象）的，它负责视图的存储，处理视图相关的动画。大部分你需要的操作都可以通过UIView提供的接口来执行。不过，如果你想更好的控制视图的渲染和动画，你可以通过它的layer对象来执行。  
为了更好的理解视图和层的关系，让我们来看一个例子。图1-1展示了视图架构与其底层的核心动画层对象之间的关系（示例来自 ViewTransitions 示例代码）。应用程序中的视图包含一个窗口（也是个视图），一个通用的UIView对象作为容器视图，一个图片视图，一个工具栏来展示按钮，以及一个bar按钮（它本身不是一个视图，但其内部管理者一个视图）。（实际上ViewTransitions 示例代码包含了一个额外的图片视图用来实现转场动画，为了简单起见，也由于该视图通常是隐藏的，就不包含在图1-1中了）每个视图都有一个相关的层对象，可以通过视图的layer属性来进行访问。（由于bar按钮不是一个视图，你不能够直接访问它的层对象。）在这些层对象背后是核心动画负责渲染对象，最后是用于管理屏幕上的实际位的硬件缓冲区。  

图1-1 一个简单应用程序的视图架构  
![](https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/view-layer-store.jpg)  

核心动画层的使用对于性能有着极为重要的影响。对于一个视图对象的实际绘制的代码要尽可能少的调用，一旦代码被调用，其结果会被核心动画所缓存下来，随后会尽可能的复用。重用已渲染过的内容将减少更新视图时通常需要消耗的代价昂贵的绘图周期。在动画期间重用这些内容尤为重要，在此期间已经存在的内容是能够被改变的。这样重用将会比创建新的内容消耗更少的资源。
### 视图层级和子视图的管理
除了提供它本身的内容之外，一个视图还能够担任其它视图的容器功能。当一个视图包含了另一个视图的时候，一个父子关系就在这两个视图之间形成了。子视图在这个关系中被称作“subview”，父视图被称作“superview”。创建这种类型的关系对应用程序的可视外观和应用程序的行为都有影响。  
在表现上，子视图会遮盖全部或者部分其父视图的内容。若子视图完全不透明，那么被子视图占据的那部分区域会完全阻止了那部分区域的父视图的响应。若子视图是部分透明的，那么在显示到屏幕之前，两个视图的这一部分内容将会融合在一起。每个父视图都以有序的形式存储其子视图，这个顺序也会影响每个子视图的显示。若两个兄弟视图有重叠的部分，那么最后被添加的那个视图（或被移动到子视图数组末尾的那个视图）将会显示在最上层。  
父子视图之间的这个关系同样会影响几个视图的行为。改变父视图的尺寸会引起连锁反应，这将导致它的子视图的大小和位置的改变。当你改变一个父视图的大小时，你可以适时的调整子视图的大小。其它会引起子视图改变的行为包括：隐藏其父视图，改变父视图的alpha值（透明度）或将一个数学上的转换应用到父视图的坐标系当中。  
视图层级当中视图的结构安排同样影响了你的应用程序如何响应事件的行为。当触摸事件发生在一个特定的视图上时，系统会发送一个携带触摸信息的事件对象给那个视图以便其对其做出响应。不过，若该视图不处理这一触摸事件的话，它可以将事件对象传递给其父视图。若父视图也不处理该事件的话，它还可以继续传递给其父视图，以此类推沿着响应链条传递。特定的视图还可以将事件对象传递给一个响应对象中介，比如视图控制器。若没有对象来接收事件的话，最终会抵达应用程序对象，通常会被忽视处理。  
更多关于如何创建视图层级的相关信息，参见“创建和管理一个视图层级”。
### 视图绘制循环
在展现内容的时候，UIView类使用的是一种请求式的绘制模型。当视图第一次呈现在屏幕上时，系统会要求它来绘制内容。然后系统会捕获它的内容的一个截图作为视图的展示内容。若你永远不改变该视图的内容的话，视图的绘制代码将永远不会被再次调用。截图的图片将会在涉及到视图的操作当中被反复使用。若你改变内容，你应当通知系统视图内容发生了变更。视图将会重复绘制视图的过程，然后将捕获新的结果的截图。  
当你的视图内容改变的时候，你不应该直接重新绘制这些变更。你应该使用 setNeedsDisplay 或 setNeedsDisplayInRect: 方法来使这些视图无效。这些方法会通知系统这些视图的内容已经发生了变更，它需要在下一个合适的时机进行重绘。系统将等待到当前运行循环的末尾, 然后再启动任何绘图操作。此延迟使您有机会使多个视图无效、添加或删除层次结构中的视图、隐藏视图、调整视图大小和重新定位视图。所有你做出的改变都会在随后的同一时间同时反映出来。  

```
注意：改变视图的几何形状不会自动触发系统重绘视图内容。视图的 contentMode 属性决定了视图的几何尺寸如何变更才会被解释执行。大部分内容模式会在当前视图的区域内拉伸或重新布局已经存在的截图而不是重新创建一个新的。更多关于内容模式如何影响你的视图绘制过程的相关信息，参见“内容模式”。
```

当渲染你的视图内容的时机到来时，实际上的绘制过程的改变依赖于视图本身和它的配置。系统通常会使用自己的方法来渲染该内容。但系统也暴露了接口让你来配置视图的实际展现形式。对于自定义的UIView的子类而言，你可以通过重写视图的 drawRect: 方法来绘制你的视图的内容。还有很多种其它的方式来提供视图的内容，比如直接设置底层的layer层，但重写 drawRect: 方法是经常使用的一种方式。  
更多关于如何绘制自定义视图内容的相关信息，参见“实现你的绘制代码”。
### 内容模式

### 拉伸视图

### 内置的动画支持

## 视图坐标系统

### frame，bounds和center等属性之间的关系

### 坐标系统的转换

### 点与像素

## 运行时视图交互模型

## 高效使用视图的建议

### 视图不总是有相关的视图控制器

### 最小化自定义绘制

### 利用内容模式

### 尽可能将视图声明为不透明的

### 当滚动的时候调整你的视图的绘制行为

### 不要通过嵌入子视图来进行自定义控制

# 窗口

## 包含窗口的任务

## 创建和配置一个窗口

### 在界面编辑器中创建窗口

### 以编码方式创建窗口

### 添加内容到你的窗口

### 更改窗口的等级

## 监控窗口的变更

## 在外部设备展示内容

### 处理屏幕的连接和断开连接的通知

### 为外部设备配置一个窗口

### 为外部展示配置屏幕模式

# 视图

## 创建和配置视图对象

### 使用界面编辑器来创建视图对象

### 编码创建视图对象

### 设定一个视图的属性

### 为视图设置将来要使用的标签

## 创建和管理视图层级

### 添加和移除子视图

### 隐藏视图

### 在视图层级中定位视图

### 转场，放大和旋转视图

### 在视图层级中转换坐标

## 在运行时调整视图的大小和位置

### 为布局的变更做好准备

### 使用自动布局的规则来自动的处理布局的变更

### 手动对你的视图布局进行调整

## 在运行时修改视图

## 与核心动画层的交互

### 改变一个视图的层级类

### 在一个视图中嵌入层级对象

## 声明一个自定义视图

### 实现一个自定义视图的检查表

### 初始化你的自定义视图

### 实现你的绘制代码

### 响应事件

### 为你的视图进行清理

# 动画

## 什么能够被动画展示？

## 一个视图中的动画属性变更

### 使用基于块的方法来开始动画

### 使用开始／提交的方法来开始动画

#### 为开始／提交动画配置参数

#### 配置动画代理

### 嵌套动画块

### 实现回调动画本身

## 在视图转场之间创建动画

### 改变一个视图的子视图

### 替换一个视图为不同的视图

## 链接多个动画

## 动画改变视图和层的变更