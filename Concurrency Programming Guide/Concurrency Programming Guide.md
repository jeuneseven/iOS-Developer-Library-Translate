[Concurrency Programming Guide 原文链接](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)

# 介绍
并发性是指很多件事在同一时间发生的一种概念。随着CPU核心数目的增加以及意识到每个处理器的核数都只增不减，软件开发人员需要一种新的方式来利用它们。尽管类似OS X和iOS这种操作系统能够同时运行多个程序，但其实大部分这些程序都是运行在后台并且执行任务的时候仅需要很少的连续处理时间。当前正在前台运行的程序既需要吸引用户的注意，又需要让处理器保持高速运行。如果一款应用程序做了很多工作，但是仅仅使用了很少部分的处理性能的话，那些额外的资源就被浪费了。  
在以前，为一款应用引入并发功能需要创建一个或多个额外的线程。而不幸的是，编写线程的代码是很有挑战性的。线程是一个底层的工具，它必须手动进行管理。  
OS X和iOS都采用了很多的异步方式来增进并发任务的执行，而非使用传统的基于线程的系统和程序。与其直接创建线程，应用仅需要定义特定的任务，然后让系统执行它就可以了。通过让系统管理线程，应用获取了
本文档描述了你可以在你的应用程序中使用的并发的方法和技术。这些技术在OS X或者iOS上都可以使用。
## 本文档的组织结构
本文档包含以下章节：  

* 并发性和应用设计一章介绍了基于异步程序的设计的基本概念以及异步执行你的任务所用到的技术。
* 操作队列一章介绍了如何使用OC对象来封装执行任务。
* 调度队列一章介绍了如何在基于C的应用中并发的执行任务。
* 调度资源一章介绍了如何异步的处理系统的事件。
* 线程切换一章提供了从你的已经存在的基于线程的代码中迁移至更新技术的一些提示和技术说明。

本文档还包含了一个术语表，该术语表定义了相关的术语。
## 关于一些术语的提示
在讨论并发性之前，有必要定义一些相关的术语来避免引起混淆。更熟悉UNIX系统或者老版本OS X技术的开发者会发现关键字“任务”，“进程”和“线程”在本文档当中的使用会有些不同。本文档会在以下途径中使用这些关键字：  

* “线程”一词用来指代分开执行的代码。线程在OS X系统上的底层实现是基于POSIX线程API的。
* “进程”一词指代正在运行的一个可执行进程，它可以包含多个线程。
* “任务”一词指代需要被执行的一项工作的抽象概念。

如需了解更详细的术语以及其他的本文档用到的关键字，参见“术语表”。
## 另请参见
本文档着重于展示在你的应用当中实现并发所使用的较新的技术，而不含盖线程的使用。如果你想使用线程或者其他线程相关的技术，参见“线程编程指南”。
# 并发性和应用设计
在计算机的早期，一台计算机的单位时间内能执行的最大计算量工作是由CPU的时钟速度决定的。但随着技术的发展和处理器的设计越来越复杂，高温和其他的物理上的约束开始限制了处理器时钟速度的最大值。因此，芯片制造商开始寻找其他的方式来提高它们芯片的性能。它们的解决方案是增加每个芯片的处理器核心数。通过增加核心数，一个单个的芯片就能够在每秒内执行更多的指令，而无需增加CPU速度或改变芯片的尺寸或温度等特征了。唯一的问题就是如何利用额外的核心了。  
为了利用多个核心，一台计算机需要软件能够同时执行多件事。对于现代的多任务操作系统，比如OSX或iOS来说，在一个给定时间内可以有上百个或更多的程序在运行，所以就能够做到将每个程序安置在不同的核心中。不过，大部分这些程序要么是被系统进程所保护，要么就是在后台消耗极少处理器时间的程序。而真正需要的其实是对于每个单个的应用程序更有效的利用多出来的核心。  
传统的让一个应用程序使用多核心的方式是创建多线程。不过，随着核心数量的增加，线程的解决方案也出现了问题。最大的问题是线程中的代码不能够很好的扩展到任意数量的核心中。你不可能在程序中创建和核心数同等数量的线程并运行良好。你需要知道的是要高效的利用一定数量的核心对于一个应用程序的如此多的线程而言也是一个挑战，要使得这些线程高效运行并且要保持它们互相不干扰也不容易。  
所以，总结一下问题，必须有一种方式让应用程序能够利用不同数量的计算机内核。一个单一应用程序执行时的工作的数量也需要能够随着变化的系统条件进行动态的调整。并且解决方案必须足够简单以便不要增加利用这些核心时的工作量。好消息是，Apple操作系统提供了所有这些问题的解决方案，本章会一窥这些设计和解决方案，并让你能够调整你的代码来利用他们。  
## 抛开线程
尽管线程存在了很多年并且还继续有它们的用处，但它不能以扩展的方式来解决常见的多任务执行问题。使用线程，创建可扩展解决方案的负担就完全落在了开发人员的肩上。你必须决定在系统条件发生改变时所创建和动态调整的线程数。另一个问题是你的应用程序应该假设大部分和创建以及持有线程所使用时所相关的消耗的情况。  
除了能够依赖线程，OSX和iOS还提供了异步设计的方法来解决并发问题。异步函数已经在操作系统中出现了很多年了，并且基本上用在需要花费很长时间的初始化任务上，比如从磁盘读取数据。当被调用时，一步函数会基于固定场景来执行相同的任务，但会在该任务还没完成时就返回了。通常来讲这种任务包含捕获后台线程，在该线程中开始需要执行的任务，然后在任务完成时给调用者发送消息（通常通过回调函数）。在过去，如果一个异步函数不存在你所需要的内容，你需要自己编写自己的一步函数然后创建自己的线程。但是现在，OSX和iOS提供了相关技术能够让你无需自己管理线程就能够执行异步任务。  
其中一个可以用来开始异步任务的技术叫做Grand Central Dispatch（GCD）。这种技术将你平常编写在你自己的应用程序中的线程管理代码移到了系统底层。你只需要定义你想要执行的任务并将其添加到适当的调度队列中即可。GCD会负责根据所需创建线程并在这些线程中调度安排你要运行的任务。由于线程管理现在是系统的一部分了，GCD提供了一种整体解决方案来管理和执行任务，这比传统的线程更为高效。  
Operation queues（操作队列）是一个OC的对象，它的表现很像调度队列。你定义好你要执行的任务，然后将其添加到操作队列中，后者负责调度和执行这些任务。像GCD一样，操作队列负责为你管理所有的线程，确保要执行的任务尽可能快和高效的在系统中执行。  
以下段落提供了关于调度队列，操作队列以及其他与你能够在应用程序中使用的异步技术的相关信息。  
### 调度队列
调度队列是一个基于C的执行自定义任务的机制。一个调度队列执行任务时，无论是串行或是并行，都是使用的先进先出的原则。（换句话说，一个调度队列始终以加入队列时同样的方式出列和开始任务。）一个串行的调度队列一次只执行一个任务，等待该任务完成后出列前再开始下一个新的任务。而与此相反，一个并行队列会有多少任务就开始执行多少任务而不会等待任何任务结束才开始。  
调度队列还有其他的好处：  

* 它提供了简单而直接的编程接口。
* 它提供自动和整体的线程池管理。
* 它提供编译调试速度。
* 它在内存上更有效率（因为线程栈并不消耗应用程序的内存）。
* 它们不会在负载下捕获到内核。
* 异步调度到调度队列的操作不会死锁队列。
* 在争夺资源上设计更合理。
* 串行调度队列为锁和其他同步基本单元提供了更有效的替代方法。

你提交到一个调度队列中的任务必须封装到一个函数或者block对象中。Block对象是一个C语言的功能，它在OSX v10.6和iOS4.0中引入，它和函数指针的概念很像，但还有一些额外的好处。你无须在block本身的词法范围内对其定义，通常是在其他的函数或方法中定义blocks，这样能够让block访问那些函数或方法中的变量。Blocks也能够从其原本的范围内移出，拷贝到堆空间中，一般在你将其提交到一个调度队列中这么做。所有的这些语法使得在实现时非常的动态，而无需多少代码量。  
调度队列是GCD技术的一部分，也是C运行时的一部分。有关在你的应用程序中使用调度队列的更多信息，参见“调度队列”。更多关于block和它的优势的相关信息，参见“Blocks编程主题”。
### 调度资源
调度资源是一种基于C的机制，它用来异步处理指定类型的系统事件。一个调度资源封装了一种特定类型的系统事件的相关信息，然后将其封装到一个特定的block对象或函数到调度队列中，不管该事件是否发生。你可以使用调度资源来监控以下类型的系统事件：  

* Timers（定时器）
* Signal handlers（信号量处理）
* Descriptor-related events（描述符相关事件）
* Process-related events（处理相关事件）
* Mach port events（Mach接口事件）
* Custom events that you trigger（你触发的自定义事件）

调度资源是GCD技术的一部分。关于使用调度资源来在你的应用程序中接收事件的相关信息，参见“调度资源”。
### 操作队列

## 异步设计的相关技术

### 定义你的应用的预期行为

### 筛选出你的可执行的工作

### 定义你需要的队列

### 提高效率的一些提示

## 性能相关的启示

## 并发性和其他相关技术

### OpenCL和并发性

### 何时该使用线程

# 操作队列

## 关于操作对象

## 并发与非并发的相对操作

## 创建NSInvocationOperation对象

## 创建NSBlockOperation对象

## 定义一个自定义的操作对象

### 执行主任务

### 响应取消事件

### 为并发执行配置操作

### 遵循KVO准则

## 为一个操作对象自定义执行的行为

### 配置相互操作的依赖

### 变更操作的执行优先级

### 改变底层的线程优先级

### 设置完成的回调Block

## 实现操作对象的一些建议

### 在操作对象中管理内存

#### 避免Per-Thread存储

#### 根据需要对你的操作对象保持引用

### 处理错误和异常

## 为操作对象决定执行范围

## 执行操作

### 添加操作对象到一个操作队列

### 手动执行操作

### 取消操作

### 等待操作完成

### 挂起和恢复队列

# 调度队列

## 关于调度队列

## 队列相关的技术

## 使用block实现任务

## 创建和管理调度队列

### 获取全局并发调度队列

### 创建串行调度队列

### 运行时获取通用队列

### 调度队列的内存管理

### 存储队列的自定义上下文信息

### 为队列提供清理函数

## 添加任务到队列中

### 添加一个单一任务到队列中

### 当任务结束的时候，执行完成回调Block

### 并发的执行循环迭代

### 在主线程执行任务

### 在你的任务中使用OC对象

## 挂起和恢复队列

## 使用调度信号量管理调度有限资源

## 等待一组队列任务

## 调度队列和线程安全

# 调度资源

## 关于调度资源

## 创建调度资源

### 编写和创建一个事件处理方法

### 创建一个取消事件处理方法

### 改变目标队列

### 使用调度资源来关联自定义数据

### 调度资源的内存管理

## 调度资源示例

### 创建timer

### 从描述符读取数据

### 为描述符编写数据

### 监听系统文件对象

### 监听信号量

### 监听进程

## 取消调度资源

## 挂起和恢复调度资源

# 从线程迁移

## 使用调度队列替换线程

## 排除基于锁的代码

### 实现异步锁

### 执行关键区域的同步

## 改进循环部分的代码

## 替代线程连接

## 改变生产－消费的实现

## 更换信号代码

## 替换运行循环的代码

## POSIX线程的兼容性

# 术语表

应用程序（application）一种特定类型的程序，用来展示图形界面给用户。  
异步设计方法（asynchronous design approach）围绕应用程序的主线程或其他执行线程同时运行的代码块组织应用程序的原则。异步任务由一个线程开启，但是实际运行在不同的线程当中，利用额外的处理资源来更快的完成它们的工作。  
block对象（block object）一种C的封装内联代码和数据的结构，它可以在稍后执行。你可以使用block封装你想要执行的任务，无论是在当前线程还是其他的使用调度队列的线程中。更多信息，参见Blocks编程主题。  
并行操作（concurrent operation）一个运算对象在它的start方法被调用的线程当中不会执行任务。并行操作通常会配置它自己的线程或者调用一个接口以设置一个单独的线程来执行操作。  
竞争（condition）一种用来同步访问资源的结构。在某个条件上等待的线程不允许继续, 直到另一个线程显式地发出该条件的信号。  
critical section  一次只能在一个线程中执行的代码片段。  
自定义source（custom source）一种调度资源，用来处理应用定义的事件。一个自定义的source会调用你的自定义的事件处理回调以响应你的应用程序生成的事件。
描述符（descriptor）一个唯一的ID，用来访问文件，socket或者其他的系统资源。  
调度队列（dispatch queue）一种GCD的结构，你可以用它来执行你app的任务。GCD为串行或并行执行任务定义了调度队列。  
调度资源（dispatch source）一种GCD的数据结构，你可以用来创建处理系统相关的事件。  
描述符调度资源（descriptor dispatch source）一种调度资源，用来处理文件相关的事件。一个文件描述符资源在文件数据可读写的时候或者响应文件系统的变化的时候会调用你的自定义的事件回调。  
动态共享库（dynamic shared library）一种二进制的可执行文件，它以动态加载的形式加载到一个应用的进程空间中，而不是以静态链接的形式作为应用程序二进制的一部分。  
类库（framework）一种bundle的类型，用来包装动态共享库，包含资源文件和头文件支持该库。更多相关信息，参见类库编程指南。  
全局调度队列（global dispatch queue）一种被GCD动态管理的提供给你的应用的调度队列。你无需自己创建全局队列或持有或释放它们。你只需要使用系统提供的函数检索它们就可以了。  
GCD 一种能够并行的异步执行任务的技术。在OS X v10.6以及iOS 4.0之后的版本可以使用。  
输入源（input source）一个线程的异步事件源。输入源可以基于接口或者手动的触发，并且必须依附于线程的运行循环。  
等待线程（joinable thread）一种接近终止时没有被立刻回收资源的线程。等待线程在资源能够被回收之前必须被显示的分离或者与另一个线程连接。等待线程为能够与其连接的线程提供返回值。  
库（library）一个UNIX用来监听底层系统事件的功能。更多信心参见kqueue主页面。  
Mach接口调度资源（Mach port dispatch source）一种调度资源，用来处理到达Mach接口的事件。  
主线程（main thread）一种特殊类型的线程，在它的进程被创建的时候，它就被创建。当一个程序的主线程终止的时候，该进程也终止。  
互斥（mutex）为共享的资源提供互斥访问的锁。一个互斥锁一次只能被一个线程持有。尝试获取由不同线程持有的互斥锁会使当前线程休眠，直到最终获取锁。    
开放式计算语言（OpenCL）一种基于标准的技术，用来在计算机的GPU上执行通用计算。更多信息，参见“OpenCL Mac编程指南”。  
运算对象（operation object）NSOperation类的实例对象。运算对象将与一个任务相关的代码和数据封装至一个可执行单元。  
运算队列（operation queue）NSOperationQueue类的实例对象。运算队列管理着运算对象的执行。  
私有调度队列（private dispatch queue）一种调度队列，由用户进行显式的创建、持有和销毁。  
进程（process）一个应用或程序的运行时实例。一个进程有其自己的虚拟内存空间以及系统资源（包括接口权限）独立于其他的程序。一个进程还包含至少一个线程（主线程）以及可以包含任意数量的额外的线程。  
进程调度资源（process dispatch source）一种调度资源，用来处理进程相关的事件。一个进程资源会调用你的自定义的事件处理回调来响应你指定的进程的更改。  
程序（program）代码和资源的集合，可以被运行来执行某些任务。程序并非必须一个图形用户界面，但图形用户界面需要考虑程序。  
可重入（reentrant）当代码已经运行在另一个线程中时，能够在一个新线程中开始安全运行的能力。  
运行循环（run loop）一个事件处理循环，在该循环内，事件被接收和调度至适当的处理回调中。  
运行循环模式（run loop mode）与输入源、timer源和运行循环观察者相关的名称的集合。当以一种指定的“模式”运行时，运行循环只监听与该模式相关的数据源和观察者。  
运行循环对象（run loop object） NSRunLoop 类的实例对象或者 CFRunLoopRef 类的不透明类型。这些对象提供了接口来在一个线程中实现一个事件处理循环。   
运行循环观察者（run loop observer）运行循环执行期间的不同阶段的通知的接收者。  
信号量（semaphore）一个受保护的变量，用来约束访问共享资源。互斥和竞争都是不同类型的信号量。  
信号（signal）一种UNIX的机制，可以在进程的作用域外操作该进程。系统使用信号来给一个应用程序传递重要信息，比如应用是否执行了非法指令。更多关于信号的相关信息，参见signal主页面。  
信号调度资源（signal dispatch source）一种调度资源，用来处理UNIX的信号。当收到一个需要处理的UNIX信号时，信号调度资源会调用你的代码来处理。  
任务（task）一些需要被执行的任务。尽管某些技术（尤其是Carbon多任务处理服务）在这个词汇上会有其他的意思，在这里我们使用只带某些需要被执行的任务的抽象概念。  
线程（thread）一个进程中的可执行流。每个线程都有它自己的栈空间，但在同一个进程中与其他线程共享内存。  
timer调度资源（timer dispatch source）一种调度资源，用来处理周期性的事件。一个timer调度资源会定期的基于时间间隔的调用你的代码来处理事件。