[Concurrency Programming Guide 原文链接](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)

# 介绍
并发性是指很多件事在同一时间发生的一种概念。随着CPU核心数目的增加以及意识到每个处理器的核数都只增不减，软件开发人员需要一种新的方式来利用它们。尽管类似OS X和iOS这种操作系统能够同时运行多个程序，但其实大部分这些程序都是运行在后台并且执行任务的时候仅需要很少的连续处理时间。当前正在前台运行的程序既需要吸引用户的注意，又需要让处理器保持高速运行。如果一款应用程序做了很多工作，但是仅仅使用了很少部分的处理性能的话，那些额外的资源就被浪费了。  
在以前，为一款应用引入并发功能需要创建一个或多个额外的线程。而不幸的是，编写线程的代码是很有挑战性的。线程是一个底层的工具，它必须手动进行管理。  
OS X和iOS都采用了很多的异步方式来增进并发任务的执行，而非使用传统的基于线程的系统和程序。与其直接创建线程，应用仅需要定义特定的任务，然后让系统执行它就可以了。通过让系统管理线程，应用获取了
本文档描述了你可以在你的应用程序中使用的并发的方法和技术。这些技术在OS X或者iOS上都可以使用。
## 本文档的组织结构
本文档包含以下章节：  

* 并发性和应用设计一章介绍了基于异步程序的设计的基本概念以及异步执行你的任务所用到的技术。
* 操作队列一章介绍了如何使用OC对象来封装执行任务。
* 分发队列一章介绍了如何在基于C的应用中并发的执行任务。
* 分发资源一章介绍了如何异步的处理系统的事件。
* 线程切换一章提供了从你的已经存在的基于线程的代码中迁移至更新技术的一些提示和技术说明。

本文档还包含了一个术语表，该术语表定义了相关的术语。
## 关于一些术语的提示
在讨论并发性之前，有必要定义一些相关的术语来避免引起混淆。更熟悉UNIX系统或者老版本OS X技术的开发者会发现关键字“任务”，“进程”和“线程”在本文档当中的使用会有些不同。本文档会在以下途径中使用这些关键字：  

* “线程”一词用来指代分开执行的代码。线程在OS X系统上的底层实现是基于POSIX线程API的。
* “进程”一词指代正在运行的一个可执行进程，它可以包含多个线程。
* “任务”一词指代需要被执行的一项工作的抽象概念。

如需了解更详细的术语以及其他的本文档用到的关键字，参见“术语表”。
## 另请参见
本文档着重于展示在你的应用当中实现并发所使用的较新的技术，而不含盖线程的使用。如果你想使用线程或者其他线程相关的技术，参见“线程编程指南”。
# 并发性和应用设计

## 抛开线程

### 分发队列

### 分发资源

### 操作队列

## 异步设计的相关技术

### 定义你的应用的预期行为

### 筛选出你的可执行的工作

### 定义你需要的队列

### 提高效率的一些提示

## 性能相关的启示

## 并发性和其他相关技术

### OpenCL和并发性

### 何时该使用线程

# 操作队列

## 关于操作对象

## 并发与非并发的相对操作

## 创建NSInvocationOperation对象

## 创建NSBlockOperation对象

## 定义一个自定义的操作对象

### 执行主任务

### 响应取消事件

### 为并发执行配置操作

### 遵循KVO准则

## 为一个操作对象自定义执行的行为

### 配置相互操作的依赖

### 变更操作的执行优先级

### 改变底层的线程优先级

### 设置完成的回调Block

## 实现操作对象的一些建议

### 在操作对象中管理内存

#### 避免Per-Thread存储

#### 根据需要对你的操作对象保持引用

### 处理错误和异常

## 为操作对象决定执行范围

## 执行操作

### 添加操作对象到一个操作队列

### 手动执行操作

### 取消操作

### 等待操作完成

### 挂起和恢复队列

# 分发队列

## 关于分发队列

## 队列相关的技术

## 使用block实现任务

## 创建和管理分发队列

### 获取全局并发分发队列

### 创建串行分发队列

### 运行时获取通用队列

### 分发队列的内存管理

### 存储队列的自定义上下文信息

### 为队列提供清理函数

## 添加任务到队列中

### 添加一个单一任务到队列中

### 当任务结束的时候，执行完成回调Block

### 并发的执行循环迭代

### 在主线程执行任务

### 在你的任务中使用OC对象

## 挂起和恢复队列

## 使用分发信号量管理调度有限资源

## 等待一组队列任务

## 分发队列和线程安全

# 分发资源

## 关于分发资源

## 创建分发资源

### 编写和创建一个事件处理方法

### 创建一个取消事件处理方法

### 改变目标队列

### 使用分发资源来关联自定义数据

### 分发资源的内存管理

## 分发资源示例

### 创建timer

### 从描述符读取数据

### 为描述符编写数据

### 监听系统文件对象

### 监听信号量

### 监听进程

## 取消分发资源

## 挂起和恢复分发资源

# 线程切换

## 使用分发队列替换线程

## 排除基于锁的代码

### 实现异步锁

### 执行关键区域的同步

## 改进循环部分的代码

## 替代线程连接

## 改变生产－消费的实现

## 更换信号代码

## 替换运行循环的代码

## POSIX线程的兼容性

# 术语表

应用程序（application）一种特定类型的程序，用来展示图形界面给用户。  
异步设计方法（asynchronous design approach）围绕应用程序的主线程或其他执行线程同时运行的代码块组织应用程序的原则。异步任务由一个线程开启，但是实际运行在不同的线程当中，利用额外的处理资源来更快的完成它们的工作。  
block对象（block object）一种C的封装内联代码和数据的结构，它可以在稍后执行。你可以使用block封装你想要执行的任务，无论是在当前线程还是其他的使用调度队列的线程中。更多信息，参见Blocks编程主题。  
并行操作（concurrent operation）一个运算对象在它的start方法被调用的线程当中不会执行任务。并行操作通常会配置它自己的线程或者调用一个接口以设置一个单独的线程来执行操作。  
条件（condition）  
critical section  
自定义source（custom source）
描述符（descriptor）  
调度队列（dispatch queue）  
调度资源（dispatch source）  
描述符调度资源（descriptor dispatch source）  
动态共享库（dynamic shared library）  
类库（framework）  
全局分发队列（global dispatch queue）  
GCD  
输入源（input source）  
等待线程（joinable thread）  
库（library）  
Mach接口调度资源（Mach port dispatch source）  
主线程（main thread）  
互斥（mutex）  
开放式计算语言（OpenCL）  
运算对象（operation object）  
运算队列（operation queue）  
私有调度队列（private dispatch queue）  
进程（process）一个应用或程序的运行时实例。一个进程有其自己的虚拟内存空间以及系统资源（包括接口权限）  
进程调度资源（process dispatch source）  
程序（program）  
可重入（reentrant）  
运行循环（run loop）  
运行循环模式（run loop mode）  
运行循环对象（run loop object）  
运行循环观察者（run loop observer）  
信号量（semaphore）  
信号（signal）  
信号调度资源（signal dispatch source）  
任务（task）  
线程（thread）一个进程中的可执行流。每个线程都有它自己的栈空间，但在同一个进程中与其他线程共享内存。  
计时调度资源（timer dispatch source）