[Concurrency Programming Guide 原文链接](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)

# 介绍
并发性是指很多件事在同一时间发生的一种概念。随着CPU核心数目的增加以及意识到每个处理器的核数都只增不减，软件开发人员需要一种新的方式来利用它们。尽管类似OS X和iOS这种操作系统能够同时运行多个程序，但其实大部分这些程序都是运行在后台并且执行任务的时候仅需要很少的连续处理时间。当前正在前台运行的程序既需要吸引用户的注意，又需要让处理器保持高速运行。如果一款应用程序做了很多工作，但是仅仅使用了很少部分的处理性能的话，那些额外的资源就被浪费了。  
在以前，为一款应用引入并发功能需要创建一个或多个额外的线程。而不幸的是，编写线程的代码是很有挑战性的。线程是一个底层的工具，它必须手动进行管理。  
OS X和iOS都采用了很多的异步方式来增进并发任务的执行，而非使用传统的基于线程的系统和程序。与其直接创建线程，应用仅需要定义特定的任务，然后让系统执行它就可以了。通过让系统管理线程，应用获取了
本文档描述了你可以在你的应用程序中使用的并发的方法和技术。这些技术在OS X或者iOS上都可以使用。
## 本文档的组织结构
本文档包含以下章节：  

* 并发性和应用设计一章介绍了基于异步程序的设计的基本概念以及异步执行你的任务所用到的技术。
* 操作队列一章介绍了如何使用OC对象来封装执行任务。
* 调度队列一章介绍了如何在基于C的应用中并发的执行任务。
* 调度资源一章介绍了如何异步的处理系统的事件。
* 线程切换一章提供了从你的已经存在的基于线程的代码中迁移至更新技术的一些提示和技术说明。

本文档还包含了一个术语表，该术语表定义了相关的术语。
## 关于一些术语的提示
在讨论并发性之前，有必要定义一些相关的术语来避免引起混淆。更熟悉UNIX系统或者老版本OS X技术的开发者会发现关键字“任务”，“进程”和“线程”在本文档当中的使用会有些不同。本文档会在以下途径中使用这些关键字：  

* “线程”一词用来指代分开执行的代码。线程在OS X系统上的底层实现是基于POSIX线程API的。
* “进程”一词指代正在运行的一个可执行进程，它可以包含多个线程。
* “任务”一词指代需要被执行的一项工作的抽象概念。

如需了解更详细的术语以及其他的本文档用到的关键字，参见“术语表”。
## 另请参见
本文档着重于展示在你的应用当中实现并发所使用的较新的技术，而不含盖线程的使用。如果你想使用线程或者其他线程相关的技术，参见“线程编程指南”。
# 并发性和应用设计
在计算机的早期，一台计算机的单位时间内能执行的最大计算量工作是由CPU的时钟速度决定的。但随着技术的发展和处理器的设计越来越复杂，高温和其他的物理上的约束开始限制了处理器时钟速度的最大值。因此，芯片制造商开始寻找其他的方式来提高它们芯片的性能。它们的解决方案是增加每个芯片的处理器核心数。通过增加核心数，一个单个的芯片就能够在每秒内执行更多的指令，而无需增加CPU速度或改变芯片的尺寸或温度等特征了。唯一的问题就是如何利用额外的核心了。  
为了利用多个核心，一台计算机需要软件能够同时执行多件事。对于现代的多任务操作系统，比如OSX或iOS来说，在一个给定时间内可以有上百个或更多的程序在运行，所以就能够做到将每个程序安置在不同的核心中。不过，大部分这些程序要么是被系统进程所保护，要么就是在后台消耗极少处理器时间的程序。而真正需要的其实是对于每个单个的应用程序更有效的利用多出来的核心。  
传统的让一个应用程序使用多核心的方式是创建多线程。不过，随着核心数量的增加，线程的解决方案也出现了问题。最大的问题是线程中的代码不能够很好的扩展到任意数量的核心中。你不可能在程序中创建和核心数同等数量的线程并运行良好。你需要知道的是要高效的利用一定数量的核心对于一个应用程序的如此多的线程而言也是一个挑战，要使得这些线程高效运行并且要保持它们互相不干扰也不容易。  
所以，总结一下问题，必须有一种方式让应用程序能够利用不同数量的计算机内核。一个单一应用程序执行时的工作的数量也需要能够随着变化的系统条件进行动态的调整。并且解决方案必须足够简单以便不要增加利用这些核心时的工作量。好消息是，Apple操作系统提供了所有这些问题的解决方案，本章会一窥这些设计和解决方案，并让你能够调整你的代码来利用他们。  
## 抛开线程
尽管线程存在了很多年并且还继续有它们的用处，但它不能以扩展的方式来解决常见的多任务执行问题。使用线程，创建可扩展解决方案的负担就完全落在了开发人员的肩上。你必须决定在系统条件发生改变时所创建和动态调整的线程数。另一个问题是你的应用程序应该假设大部分和创建以及持有线程所使用时所相关的消耗的情况。  
除了能够依赖线程，OSX和iOS还提供了异步设计的方法来解决并发问题。异步函数已经在操作系统中出现了很多年了，并且基本上用在需要花费很长时间的初始化任务上，比如从磁盘读取数据。当被调用时，一步函数会基于固定场景来执行相同的任务，但会在该任务还没完成时就返回了。通常来讲这种任务包含捕获后台线程，在该线程中开始需要执行的任务，然后在任务完成时给调用者发送消息（通常通过回调函数）。在过去，如果一个异步函数不存在你所需要的内容，你需要自己编写自己的一步函数然后创建自己的线程。但是现在，OSX和iOS提供了相关技术能够让你无需自己管理线程就能够执行异步任务。  
其中一个可以用来开始异步任务的技术叫做Grand Central Dispatch（GCD）。这种技术将你平常编写在你自己的应用程序中的线程管理代码移到了系统底层。你只需要定义你想要执行的任务并将其添加到适当的调度队列中即可。GCD会负责根据所需创建线程并在这些线程中调度安排你要运行的任务。由于线程管理现在是系统的一部分了，GCD提供了一种整体解决方案来管理和执行任务，这比传统的线程更为高效。  
Operation queues（操作队列）是一个OC的对象，它的表现很像调度队列。你定义好你要执行的任务，然后将其添加到操作队列中，后者负责调度和执行这些任务。像GCD一样，操作队列负责为你管理所有的线程，确保要执行的任务尽可能快和高效的在系统中执行。  
以下段落提供了关于调度队列，操作队列以及其他与你能够在应用程序中使用的异步技术的相关信息。  
### 调度队列
调度队列是一个基于C的执行自定义任务的机制。一个调度队列执行任务时，无论是串行或是并行，都是使用的先进先出的原则。（换句话说，一个调度队列始终以加入队列时同样的方式出列和开始任务。）一个串行的调度队列一次只执行一个任务，等待该任务完成后出列前再开始下一个新的任务。而与此相反，一个并行队列会有多少任务就开始执行多少任务而不会等待任何任务结束才开始。  
调度队列还有其他的好处：  

* 它提供了简单而直接的编程接口。
* 它提供自动和整体的线程池管理。
* 它提供编译调试速度。
* 它在内存上更有效率（因为线程栈并不消耗应用程序的内存）。
* 它们不会在负载下捕获到内核。
* 异步调度到调度队列的操作不会死锁队列。
* 在争夺资源上设计更合理。
* 串行调度队列为锁和其他同步基本单元提供了更有效的替代方法。

你提交到一个调度队列中的任务必须封装到一个函数或者block对象中。Block对象是一个C语言的功能，它在OSX v10.6和iOS4.0中引入，它和函数指针的概念很像，但还有一些额外的好处。你无须在block本身的词法范围内对其定义，通常是在其他的函数或方法中定义blocks，这样能够让block访问那些函数或方法中的变量。Blocks也能够从其原本的范围内移出，拷贝到堆空间中，一般在你将其提交到一个调度队列中这么做。所有的这些语法使得在实现时非常的动态，而无需多少代码量。  
调度队列是GCD技术的一部分，也是C运行时的一部分。有关在你的应用程序中使用调度队列的更多信息，参见“调度队列”。更多关于block和它的优势的相关信息，参见“Blocks编程主题”。
### 调度资源
调度资源是一种基于C的机制，它用来异步处理指定类型的系统事件。一个调度资源封装了一种特定类型的系统事件的相关信息，然后将其封装到一个特定的block对象或函数到调度队列中，不管该事件是否发生。你可以使用调度资源来监控以下类型的系统事件：  

* Timers（定时器）
* Signal handlers（信号量处理）
* Descriptor-related events（描述符相关事件）
* Process-related events（处理相关事件）
* Mach port events（Mach接口事件）
* Custom events that you trigger（你触发的自定义事件）

调度资源是GCD技术的一部分。关于使用调度资源来在你的应用程序中接收事件的相关信息，参见“调度资源”。
### 操作队列
操作队列是Cocoa中一个与并发调度队列等价，并由NSOperationQueue类实现的功能。由于调度队列总是以先进先出的顺序来执行任务，操作队列会在决定任务的执行顺序时考虑其他的因素。首先要考虑的因素是一个给定的任务是否依赖于其他任务的结束。当定义你的任务时，你需要配置依赖关系，然后就可以使用它们来为你的任务创建复杂的执行顺序了。  
你提交给操作队列的任务必须是NSOperation类的实例对象。一个operation对象是一个OC对象，它封装了你想要执行的工作和需要执行时所需要的数据。由于NSOperation类本质上是一个抽象基类，通常都是定义自定义的子类来执行你的任务。不过，Foundation框架中包含一些具体的子类，你可以使用它们来创建和执行任务。  
操作对象会生成键值监听（KVO）通知，这是一种非常有效的监控任务过程的方式。尽管操作队列执行操作一直都是并行的，但是你可以根据需要来决定它们在串行执行时的依赖关系。  
更多关于如何使用操作队列的信息，以及如何定义自定义的操作对象，参见“操作队列”。
## 异步设计的相关技术
在你考虑重新设计你的代码来支持并发之前，你应该问你自己，这么做是否必要。并发性确实能够通过让你的主线程快速响应用户的事件来提高你的代码的响应能力。甚至可以通过更多的核心数的杠杆作用，在同一时间内做更多的工作来提高你的代码的效率。不过，它也增加了开销并提高了你的代码的整体的复杂度，让编写和调试你的代码更困难了。  
由于增加了复杂度，并发功能就不能够在你的发布周期末尾再接入到你的应用程序中了。并且在接入时需要仔细考虑你的应用程序执行时的任务以及执行这些任务时所需的数据结构。如果做错了，你会发现你的代码运行的比以前还慢并且给用户的反馈更少了。所以，有必要在你的设计阶段就花时间来设置一些目标以及考虑你的接入方案。  
每款应用程序都有不同的环境要求和不同的执行任务。所以不可能有个文档告诉你如何设计你的应用程序和相关的任务。不过，以下段落会尝试为你提供一些指南来帮助你在设计期间作出更好的选择。
### 定义你的应用的预期行为
在你思考关于添加并发功能到你的应用程序之前，你应该先从定义好你的应用程序的所需的功能开始。理解了你的应用程序所预期的行为会给你随后验证提供一个思路。在引入并发之后，还会给你一些预期的性能提高的收益。  
首先你应该列举你的应用程序所执行的任务和对象或每个任务所关联的数据结构。首先，你可以从用户选择了一个元素或点击了一个按钮所执行的任务开始。这些任务拥有分离好的行为并且边界定义良好。你还可以列举你的应用程序中不需要用户交互的执行的任务，比如基于定时器的任务。  
当你列举出了高优任务之后，应该开始着手将每个任务进一步分解为成功完成任务所需执行的一组步骤。在这个层面上，你应当首先关心你需要将数据结构和对象做出的调整，以及调整所对你的整体的应用程序状态所来带的影响。你还应该关注对象和数据结构之间的依赖关系。举例来说，若一个任务涉及将一个数组中的对象进行相同的更改，那么值得注意的是对一个对象的更改是否会影响其他的对象。若一个对象可以独立的不依赖彼此进行修改的话，那么你就可以在这种地方使用并发来进行修改了。  
### 筛选出你的可执行的工作
从你开始理解了你的应用程序所执行的任务开始，你应该准备好鉴别出在你的代码中，哪部分使用并发可能带来收益。如果改变一个任务中的一个或多个步骤的顺序会改变结果的话，你可能就需要顺序的执行这些步骤了。但如果改变顺序不会影响输出，你就可以考虑使用并发来执行这些步骤。不论哪种情况，你都应该定义需要执行的工作单元来代表一步一步需要执行的任务。这种工作单元随后会由你使用block或者一个操作对象或者调度队列来进行封装。  
对于每一个你定义的可执行的工作单元，不要担心需要执行的这些工作单元太多，至少在最开始不要担心。尽管线程切换是有成本的，调度队列和操作队列的优势是在很多情况下的开销都比传统线程要小很多。因此，你使用队列来执行较小的工作单元要比使用线程更为高效。当然，你应该始终关注实际性能并根据所需调整你的任务的大小，但在最开始，不应该将任务考虑的太小。  
### 定义你需要的队列
现在，你的任务已经被分解成了严格区分的工作单元，并使用block对象或者操作对象进行了封装，你需要做的就是定义你要执行代码的队列。对于一个给定的任务，要检测你所创建的block或操作对象以及它们执行任务时的执行顺序是否正确。  
若你使用blocks实现你的任务，你可以将你的blocks添加到串行或并行调度队列中。若需要指定一个顺序的话，你应当将你的blocks添加到一个串行调度队列中。若不需要，你就可以将blocks添加到一个并行调度队列或将其添加到几个不同的调度队列中，看你自己的需要了。  
若你实现你的任务时使用的是操作对象的话，队列的选择要比对象的配置要少一些了。要串行的执行操作对象的话，你必须配置对象之间的依赖关系。依赖关系可以阻止一个操作，直到它所依赖的对象完成其工作。
### 提高效率的一些提示
除了简单的将你的代码分成更小的任务并将其添加到队列中，在使用队列时还有一些其他的方法来提高整体效率：  

* 若内存的使用是一个影响因素的话，可以考虑直接在你的任务中计算值。若你的应用程序已经被内存绑定，那么直接计算值可能要比从主内存中加载缓存值要快得多。使用寄存器和处理器缓存来计算值通常要比主内存要快得多。当然，只有在确定在性能提高很多的时候你才应该这么做。
* 尽早判断出串行任务，然后尽可能将其变成并行。如果一个任务必须被串行的执行是因为其依赖于某些共享资源的话，你可以考虑将你的结构调整为移除该共享资源。你可以考虑给每个客户端一份资源的拷贝或整体将资源消除。
* 避免使用锁。在大部分情况下，调度队列和操作队列所提供的支持使得锁没有什么必要存在。你无须使用锁来保护某些共享资源，你可以指定一个串行队列（或根据依赖关系使用操作队列）来以正确的顺序来执行任务。
* 尽可能的依赖于系统的框架。实现并发最好的方式是利用系统框架内置的并发技术。很多框架内部使用的是线程和其他的技术来实现并发行为。当定义你的任务时，要看看是否已经有框架定义了一个函数或方法是你所需的那种并发执行。使用该API会节省你的时间并且能够最大限度的使用并发。

## 性能相关的启示
操作队列，调度队列和调度资源都是提供给你用来并发执行代码更为简单的工具。不过这些技术并不保证能够提升你的应用程序的效率或响应能力。你还是要负责使用队列来管理你所需要的效率并且不要让你的应用程序过度加载其他的资源。比如，即使你能够创建一万个操作对象并将其提交到一个操作队列中，但是这么做会让你的应用程序申请一个无比巨大的内存量，这可能会导致性能的降低。  
在给你的代码引入任何形式的并发之前——不论是使用队列还是线程——你应该尽量收集你的应用程序当前性能的一些指标。在引入这些技术之后，你应该继续收集额外的信息并与之前的指标进行比较，看你的应用程序整体效率是否提升。若引入并发让你的应用程序更低效或者响应更差了，你应该使用性能检测工具来检测是否有潜在的问题。  
有关性能和可以用到的一些检测性能的工具的相关介绍，以及一些高级性能相关的主题，参见“性能概览”。
## 并发性和其他相关技术
将你的代码分解为模块化的任务是在你的应用程序中应用并发性最好的方式。不过，这种方式可能并不适用于每款应用程序。根据任务的不同，可能有其他的选项能够对于你的应用程序提供额外的提升。这个段落提供了一些你可以考虑作为你设计一部分的其他相关技术的概要。  
### OpenCL和并发性
在OSX中，开放式计算语言（OpenCL）是一个用来在计算机的图形处理器上执行通用计算的基于标准的技术。当你有一组定义好的计算数据需要应用到大数据集合上时，OpenCL是一个你可以使用的很好的技术。举例来说，OpenCL可以让你用来过滤一个图片的每个像素或者用来一次性执行复杂数学计算中的每个值。换句话说，OpenCL就是为了那些能够并行操作的数据所准备的解决方案。  
尽管OpenCL很适合用来执行大数据并行操作，但它不适合通用计算。准备数据和所需的工作内核并将其传输到图形卡所需的工作量非常大, 以便它可以由 GPU 操作。同样的，也需要检索由OpenCL生成的大量的数据结果。所以，任何需要与系统进行交互的任务通常都不推荐使用OpenCL。比如，你最好别使用OpenCL来处理从文件或网络流中获取到的数据。相反地，你使用OpenCL执行的工作最好是能够独立的，以便它能够传输到图形处理器上并独立计算。  
更多关于OpenCL的相关信息以及你如何使用它，参见“Mac中的OpenCL编程指南”。
### 何时该使用线程
尽管操作队列和调度队列在执行并发任务时是更好的方式，但它并不是万能的。根据应用程序的不同，还是有很多地方需要你创建自定义的线程的。若你需要创建自定义的线程，你应该尽量少的创建线程，并且在使用线程时应当用在特定的任务上而不是去实现其他的任务。  
线程在实际运行中依旧是实现代码的一个很好的方式。调度队列会尽可能快的运行它的任务，但它不能解决实时约束。若你对于后台运行的代码需要更加可预期的行为的话，线程依旧会提供一个更好的替代方案。  
在使用线程编程时，你应该谨慎并且只在必要时才使用。更多关于线程封装以及如何使用的相关信息，参见“多线程编程指南”。
# 操作队列

## 关于操作对象

## 并发与非并发的相对操作

## 创建NSInvocationOperation对象

## 创建NSBlockOperation对象

## 定义一个自定义的操作对象

### 执行主任务

### 响应取消事件

### 为并发执行配置操作

### 遵循KVO准则

## 为一个操作对象自定义执行的行为

### 配置相互操作的依赖

### 变更操作的执行优先级

### 改变底层的线程优先级

### 设置完成的回调Block

## 实现操作对象的一些建议

### 在操作对象中管理内存

#### 避免Per-Thread存储

#### 根据需要对你的操作对象保持引用

### 处理错误和异常

## 为操作对象决定执行范围

## 执行操作

### 添加操作对象到一个操作队列

### 手动执行操作

### 取消操作

### 等待操作完成

### 挂起和恢复队列

# 调度队列

## 关于调度队列

## 队列相关的技术

## 使用block实现任务

## 创建和管理调度队列

### 获取全局并发调度队列

### 创建串行调度队列

### 运行时获取通用队列

### 调度队列的内存管理

### 存储队列的自定义上下文信息

### 为队列提供清理函数

## 添加任务到队列中

### 添加一个单一任务到队列中

### 当任务结束的时候，执行完成回调Block

### 并发的执行循环迭代

### 在主线程执行任务

### 在你的任务中使用OC对象

## 挂起和恢复队列

## 使用调度信号量管理调度有限资源

## 等待一组队列任务

## 调度队列和线程安全

# 调度资源

## 关于调度资源

## 创建调度资源

### 编写和创建一个事件处理方法

### 创建一个取消事件处理方法

### 改变目标队列

### 使用调度资源来关联自定义数据

### 调度资源的内存管理

## 调度资源示例

### 创建timer

### 从描述符读取数据

### 为描述符编写数据

### 监听系统文件对象

### 监听信号量

### 监听进程

## 取消调度资源

## 挂起和恢复调度资源

# 从线程迁移

## 使用调度队列替换线程

## 排除基于锁的代码

### 实现异步锁

### 执行关键区域的同步

## 改进循环部分的代码

## 替代线程连接

## 改变生产－消费的实现

## 更换信号代码

## 替换运行循环的代码

## POSIX线程的兼容性

# 术语表

应用程序（application）一种特定类型的程序，用来展示图形界面给用户。  
异步设计方法（asynchronous design approach）围绕应用程序的主线程或其他执行线程同时运行的代码块组织应用程序的原则。异步任务由一个线程开启，但是实际运行在不同的线程当中，利用额外的处理资源来更快的完成它们的工作。  
block对象（block object）一种C的封装内联代码和数据的结构，它可以在稍后执行。你可以使用block封装你想要执行的任务，无论是在当前线程还是其他的使用调度队列的线程中。更多信息，参见Blocks编程主题。  
并行操作（concurrent operation）一个运算对象在它的start方法被调用的线程当中不会执行任务。并行操作通常会配置它自己的线程或者调用一个接口以设置一个单独的线程来执行操作。  
竞争（condition）一种用来同步访问资源的结构。在某个条件上等待的线程不允许继续, 直到另一个线程显式地发出该条件的信号。  
critical section  一次只能在一个线程中执行的代码片段。  
自定义source（custom source）一种调度资源，用来处理应用定义的事件。一个自定义的source会调用你的自定义的事件处理回调以响应你的应用程序生成的事件。
描述符（descriptor）一个唯一的ID，用来访问文件，socket或者其他的系统资源。  
调度队列（dispatch queue）一种GCD的结构，你可以用它来执行你app的任务。GCD为串行或并行执行任务定义了调度队列。  
调度资源（dispatch source）一种GCD的数据结构，你可以用来创建处理系统相关的事件。  
描述符调度资源（descriptor dispatch source）一种调度资源，用来处理文件相关的事件。一个文件描述符资源在文件数据可读写的时候或者响应文件系统的变化的时候会调用你的自定义的事件回调。  
动态共享库（dynamic shared library）一种二进制的可执行文件，它以动态加载的形式加载到一个应用的进程空间中，而不是以静态链接的形式作为应用程序二进制的一部分。  
类库（framework）一种bundle的类型，用来包装动态共享库，包含资源文件和头文件支持该库。更多相关信息，参见类库编程指南。  
全局调度队列（global dispatch queue）一种被GCD动态管理的提供给你的应用的调度队列。你无需自己创建全局队列或持有或释放它们。你只需要使用系统提供的函数检索它们就可以了。  
GCD 一种能够并行的异步执行任务的技术。在OS X v10.6以及iOS 4.0之后的版本可以使用。  
输入源（input source）一个线程的异步事件源。输入源可以基于接口或者手动的触发，并且必须依附于线程的运行循环。  
等待线程（joinable thread）一种接近终止时没有被立刻回收资源的线程。等待线程在资源能够被回收之前必须被显示的分离或者与另一个线程连接。等待线程为能够与其连接的线程提供返回值。  
库（library）一个UNIX用来监听底层系统事件的功能。更多信心参见kqueue主页面。  
Mach接口调度资源（Mach port dispatch source）一种调度资源，用来处理到达Mach接口的事件。  
主线程（main thread）一种特殊类型的线程，在它的进程被创建的时候，它就被创建。当一个程序的主线程终止的时候，该进程也终止。  
互斥（mutex）为共享的资源提供互斥访问的锁。一个互斥锁一次只能被一个线程持有。尝试获取由不同线程持有的互斥锁会使当前线程休眠，直到最终获取锁。    
开放式计算语言（OpenCL）一种基于标准的技术，用来在计算机的GPU上执行通用计算。更多信息，参见“OpenCL Mac编程指南”。  
运算对象（operation object）NSOperation类的实例对象。运算对象将与一个任务相关的代码和数据封装至一个可执行单元。  
运算队列（operation queue）NSOperationQueue类的实例对象。运算队列管理着运算对象的执行。  
私有调度队列（private dispatch queue）一种调度队列，由用户进行显式的创建、持有和销毁。  
进程（process）一个应用或程序的运行时实例。一个进程有其自己的虚拟内存空间以及系统资源（包括接口权限）独立于其他的程序。一个进程还包含至少一个线程（主线程）以及可以包含任意数量的额外的线程。  
进程调度资源（process dispatch source）一种调度资源，用来处理进程相关的事件。一个进程资源会调用你的自定义的事件处理回调来响应你指定的进程的更改。  
程序（program）代码和资源的集合，可以被运行来执行某些任务。程序并非必须一个图形用户界面，但图形用户界面需要考虑程序。  
可重入（reentrant）当代码已经运行在另一个线程中时，能够在一个新线程中开始安全运行的能力。  
运行循环（run loop）一个事件处理循环，在该循环内，事件被接收和调度至适当的处理回调中。  
运行循环模式（run loop mode）与输入源、timer源和运行循环观察者相关的名称的集合。当以一种指定的“模式”运行时，运行循环只监听与该模式相关的数据源和观察者。  
运行循环对象（run loop object） NSRunLoop 类的实例对象或者 CFRunLoopRef 类的不透明类型。这些对象提供了接口来在一个线程中实现一个事件处理循环。   
运行循环观察者（run loop observer）运行循环执行期间的不同阶段的通知的接收者。  
信号量（semaphore）一个受保护的变量，用来约束访问共享资源。互斥和竞争都是不同类型的信号量。  
信号（signal）一种UNIX的机制，可以在进程的作用域外操作该进程。系统使用信号来给一个应用程序传递重要信息，比如应用是否执行了非法指令。更多关于信号的相关信息，参见signal主页面。  
信号调度资源（signal dispatch source）一种调度资源，用来处理UNIX的信号。当收到一个需要处理的UNIX信号时，信号调度资源会调用你的代码来处理。  
任务（task）一些需要被执行的任务。尽管某些技术（尤其是Carbon多任务处理服务）在这个词汇上会有其他的意思，在这里我们使用只带某些需要被执行的任务的抽象概念。  
线程（thread）一个进程中的可执行流。每个线程都有它自己的栈空间，但在同一个进程中与其他线程共享内存。  
timer调度资源（timer dispatch source）一种调度资源，用来处理周期性的事件。一个timer调度资源会定期的基于时间间隔的调用你的代码来处理事件。