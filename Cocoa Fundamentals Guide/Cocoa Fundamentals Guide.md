[Cocoa Fundamentals Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/Introduction/Introduction.html#//apple_ref/doc/uid/TP40002974-CH1-SW1)

# 简介

对于开发新手而言，Cocoa可能像是个汪洋大海，未知的技术的新世界。各种功能，工具，概念，设计，术语，编程接口以及这种开发环境的编程语言都可能不熟悉。Cocoa基础指南让熟悉Cocoa这一初始步骤变得简单。它为Cocoa的技术概览提供了方向。它介绍了其功能，基本概念，术语，体系结构和底层设计模式。  
你可以为两个平台构建Cocoa应用：OS X操作系统和iOS，类似iPhone，iPad和iPod touch的多点触控设备操作系统。Cocoa基础指南展现了两个平台中与Cocoa相关的信息，尽可能的整合了信息并在必要的位置指出平台的差异。目的是一旦你对Cocoa的一个平台熟悉了，很容易就从一个软件开发平台的知识迁移到另一个。  
Cocoa基础指南意在逐步理解Cocoa开发全貌。它从基本信息开始——什么是Cocoa遵照的组建和能力——并以查阅其主要架构为止。每个章节都在其前一章节解释了。每个段落都对于一个子模块介绍了详情，但只在一个较高层次进行描述。一个段落会经常将你引用到另一个提供更全面描述的文档。    
在Cocoa 开发文档集合中，《Cocoa基础指南》是概念入口文档。对于阅读其他基本Cocoa指南是先决条件，比如《Cocoa绘制指南》，《视图编程指南》，以及《iOS应用编程指南》。《Cocoa基础指南》会依据先导阅读，但读者应该精通C语言编程并属性他们将要进行开发的平台的能力和技术，你可以通过阅读《Mac技术概览》对此熟悉，对于iOS而言，阅读《iOS技术概览》。

## 本文档组织结构

Cocoa基础指南有如下章节：  

* 什么是Cocoa？ 从功能性和概括性的结构透析介绍了Cocoa，描述了其功能，框架和开发环境。
* Cocoa对象 阐释了优势和OC的基本使用，还介绍了常用功能，接口和所有Cocoa对象的生命周期。
* 给一个Cocoa程序添加行为 描述了使用Cocoa框架编写一个程序是什么样的，以及解释了如何创建一个子类。
* Cocoa设计模式 描述了Cocoa适配设计模式，特别是MVC和对象模型。
* 与对象进行交互 讨论了编程接口和在Cocoa对象之间的沟通机制，包括代理，通知和绑定。

## 另请参阅

在技术书库中你还可以找到很多优秀的第三方介绍Cocoa的文章。你可以用这些书补充你在Cocoa基础指南中的所学。此外，还有一些其他的Apple文章你也可以作为一个Cocoa开发者阅读：  

* OC编程语言 描述了OC编程语言和运行时环境。
* 模型对象实现指南 讨论了子类设计和实现的基本问题。
* 开发CocoaOC应用程序 《教程》展示了如何使用Xcode开发环境构建一个简单的OS X的Cocoa应用程序，Cocoa框架和OC。《你的第一个iOS应用》是一份引导你从创建一个简单的iOS应用到展示如何使用基本的Xcode开发环境以及OC和Cocoa框架的指南。
* iOS应用编程指南 介绍了用来开发运行iOS设备的应用程序的特定框架。

# 什么是Cocoa？

Cocoa 是一个在OS X操作系统以及iOS上的应用程序环境，操作系统是用在类似iPhone，iPad, 和 iPod touch等设备上的。它由一组面向对象的软件库，一个运行时系统，以及一个整合的开发环境组成。  
本章扩展了此定义，描述了 Cocoa 在两个平台上的目的、功能和组件。阅读Cocoa的功能描述对于Cocoa的开发人员来说是重要的第一步。  

## Cocoa环境

Cocoa是一套面向对象的框架，它为运行在OS X和iOS上的应用程序提供了运行时环境。Cocoa对于OS X是一个优秀的应用程序环境，但对于iOS来讲是唯一的应用环境。（Carbon是一个在OS X的替代环境，但它是一个可以与共存的框架）

### Cocoa简介

### Cocoa是如何适配OS X的

### Cocoa是如何适配iOS的

## Cocoa应用的功能

## 开发环境

### 平台SDKs

### 开发流程概览

### Xcode

### 界面编辑器

### iOS模拟器应用

### 性能应用和工具

## Cocoa框架

### Foundation

### AppKit (OS X)

### UIKit (iOS)

### AppKit和UIKit类对比

### Core Data

### 其他框架和Cocoa API

## 一点历史

# Cocoa对象

## 一个简单的Cocoa命令行工具

## OC面向对象编程

Cocoa中遍布面向对象，从其编程范式到其机制再到其事件驱动架构。OC，Cocoa的开发语言，也是彻底的面向对象，尽管其基础是ANSI C。它为消息分发和定义新的类并指定句法约定提供了运行时支持。OC支持其他编程语言类似C++和Java等的大部分的抽象和机制。这包括继承，封装，复用和多态。  
但OC与其他面向对象语言不同，尤其是在比较重要的地方。比如，OC不像C++，不允许运算符重载，模板或者多重继承。  
尽管OC没有这些功能，但它作为一个面向对象的编程语言是有所补偿的。下文继续探究OC的特殊功能。  

```
附加阅读：《OC编程语言》大部分章节的简介信息都可以作为OC语言的最佳指导，查阅该文档作为详情和OC的补充介绍。
```

### OC的优势

如果你是一个面向对象概念的新手程序员，首先把一个对象从根本上看作是一些功能的关联可能会比较有帮助。这一理解距离实际并不遥远，尤其是在运行时的实现中。  
每个OC对象都隐藏了其首个成员数据结构——或者实例变量——即isa指针。（大部分剩下的成员都由对象和其父类定义。）  isa指针，就如其名字所暗示的那样，指向对象的类，它本身是一个对象（参见图2-1），是从类定义编译的。类对象维护了一个调度表，该调度表基本上由指向它实现的方法的指针组成；它还指向其父类的指针，其父类页游其自己的调度表和父类指针。通过此引用链，对象可以访问它的类以及所有其父类所实现的方法（所有继承的公开和受保护的实例变量）。isa指针对于消息调度机制和Cocoa对象的动态性至关重要。  

图 2-1 一个对象的isa指针  
![](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/Art/ns_gadget.gif)  

对象外层所展现的内容是对OC运行时发生的情况的一个非常简化的视图，以启用消息调度、继承和常规对象行为的其他方面。但是这些信息对于理解OC的目标优势以及其动态性至关重要。  

### OC的动态性

OC是非常动态化的语言。它的动态性将程序从编译时和链接时的约束释放出来，并当用户可以控制时为符号化分析转移了大量功能到运行时。OC比其他编程语言更加动态，因为它的动态性来自三个来源：  

* 动态类型——在运行时判断一个对象的类
* 动态绑定——在运行时判断调用的方法
* 动态加载——在运行时添加新的模块给程序

对于动态类型，OC引入了id数据类型，它可以表示任意Cocoa对象。这种常见对象类型的使用展示在清单2-2中：  

	id word;
	while (word = [enm nextObject]) {
	    // do something with 'word' variable....
	}

id数据类型可以在运行时代替任意类型的对象。因此，你可以让运行时因素决定代码中使用的对象类型。动态类型能够让对象在运行时进行关联而非强制在静态设计时被编码。编译时的静态类型检测可能会严格校验数据的完整性，但作为严格校验完整性的交换，动态类型给予了你的程序很大的灵活性。并随着对象的自省能力（比如查询一个动态类型，匿名该对象的类型）你可以在运行时校验该对象的类型，并在特定的操作中证实其适当性。（当然，你可以在你需要的时候始终使用静态检测该对象的类型。）  
动态类型为动态绑定提供了实质，OC的第二个动态机制。就像动态类型将一个对象的类的从属关系推迟到了运行时才决定一样，动态绑定将该调用哪个方法推迟到了运行时才决定。方法调用在编译期间不绑定到代码；它们仅在实际消息传递时被绑定。由于同时拥有动态绑定和动态类型，你可以在每次执行代码时获得不同的结果。运行时因素决定哪个接收者被选择以及调用了哪个方法。  
运行时消息分发机制让动态绑定成为可能。当你发送一个消息给一个动态类型的对象时，运行时系统会使用接收者的isa指针定位对象的类型，然后从该类型中调用方法的实现。方法是动态绑定给消息的。并且你不需要在你的OC代码中做任何事就能够获取到动态绑定的好处。它在你发送一条消息时是例行公事和显在的发生的，尤其是给一个动态类型的对象发送消息时。  
动态加载，最后一个动态机制类型，是一个依赖于OC运行时支持的Cocoa功能。由于拥有动态加载，Cocoa程序能够在它们需要的时候加载可执行代码和资源，而不必在启动时就将所有的程序组件都载入。可执行代码（链接优先加载）通常包含成为整合到运行时程序镜像的新的类。无论是代码还是本地资源（包括nib文件）都会打包进bundle中，并显式加载到Foundation的 NSBundle 类中定义的方法中。  
这种程序代码和资源的"延迟加载"通过降低对系统的内存要求来提高整体性能。更重要的是，动态加载使得应用程序变得可以扩展。你可以为你的应用程序设计一个插件架构，允许你或者其他的开发者定制额外的模块，以便让应用程序在数月甚至数年后发布时动态加载。如果设计正确，这些模块的类将不会与已经存在的类冲突，因为每个类封装其实现并拥有自己的命名空间。  

### OC的扩展性

OC突出了四种扩展性，都是在软件开发领域非常有力的工具：分类，协议，声明属性和快速枚举。某些扩展为生命属性和将其关联类引入了不同的技术。其他的提供了便捷方法访问对象的属性，快速枚举集合，处理异常和执行其他任务。  

#### 分类

分类给予了你一种无需创建子类就能够给一个类添加方法的方式。分类中的方法会变成类类型的一部分（只限于你的程序中）并被所有该类的子类所继承。在运行时原方法和添加的方法没有区别。你可以发送一条消息给任意类（或其子类）的实例来调用在分类中定义的方法。  
分类不只是给一个类添加行为的便捷方式。你还可以使用分类来区分方法，分组相关的方法到不同的分类中。分类能够被灵活的用来处理组织大型的类；你甚至可以将不同的分类放到不同的源文件中，对于实例而言，可以有不同的开发者使用同一个类。  
声明和实现一个分类就像执行子类一样。从语法上，唯一的区别是分类的名称，它遵循@interface或@implementation指令，并放在括号中。举个例子，假设你想要添加一个NSArray 类的方法来以更结构化的方式打印该集合的信息的话。在分类的头文件中，编写类似以下声明的代码即可：  

	#import <Foundation/NSArray.h> // if Foundation not already imported
 
	@interface NSArray (PrettyPrintElements)
	- (NSString *)prettyPrintDescription;
	@end

然后在实现文件中你可以编写如下代码：  

	#import “PrettyPrintCategory.h”
 
	@implementation NSArray (PrettyPrintElements)
	- (NSString *)prettyPrintDescription {
	    // implementation code here...
	}
	@end

对于分类有一些限制。你不能使用分类来给该类添加任何新的实例变量。虽然一个分类方法能够重写一个已经存在的方法，但我们不推荐你这么做，尤其是你想要扩大当前的行为时。这种警告的其中一个原因是分类方法是类的头文件的一部分，所以没有一种方式是发送一个消息给super来获取已经被类定义的行为。如果你需要改变一个该类已经存在的方法的话，最好是声明一个该类的子类。  
你可以给根类NSObject定义分类添加方法。这些方法会对于所有链接到你的代码的实例以及类对象都可用。非正式协议——Cocoa代理机制的基础——就是声明为NSObject的分类的。不过，过度曝光对于其使用也是危险共存的。你通过分类添加到NSObject的每个对象都可能会遇到你事先没有预料到的问题，导致崩溃，数据污染，甚至更糟。  

#### 协议

OC的另一个扩展protocol非常像Java中的接口。都是直接把一系列方法声明在一个公开的接口中，其他类都可以选择实现。协议中的方法被某些其他类的实例对象发送的消息调用。  
协议的主要价值是它们很像分类，能够替代子类。它产生了在C++中的多重继承的优势，能够共享接口（如果没有实现）。接口也是一种让类声明一个接口时想要隐藏其身份的一种方式。接口可能会暴露一个类要提供的所有或者（通常来讲）一部分服务。整个类继承等级的其他类，不一定在任何继承关系（甚至不到根类），可以实现该协议的方法，因而访问已经公开的服务。使用协议，即使对另一个类的身份一无所知（即类的类型）也能够与该类以协议发布的特定目的进行通信。  
有两种类型的协议：正式和非正式。非正式协议在“协议”中简单提过。即NSObject的分类；因此，每个以NSObject作为其根类的对象（类对象也是）隐含的已经采用了在分类中公开的接口。要使用一个非正式协议，一个类不需要实现它其中声明的每个方法，只需要实现它想要实现的即可。至于非正式协议是如何工作的，类声明的非正式协议在给目标对象发送协议消息之前必须正确响应从一个目标对象发出的respondsToSelector: 方法消息。（如果目标对象没有实现方法，会有一个运行时异常。）  
正式协议在Cocoa中通常被设计为protocol。它让一个类正式的声明一系列的需要公开服务的接口。OC语言和运行时系统支持正式协议；编译器会检测基于协议的类型，对象可以在运行时进行内省来检验一个协议的一致性。正式协议有其自己的术语和语法。对于发布者和客户端术语有所不同：  

* 发布者（通常是一个类）声明正式协议。
* 客户端类采用一个正式协议，这样做既为同意实现所有协议中要求的方法。
* 如果一个类采用了或者继承了一个类采用的一个协议，那么类要遵循一个正式协议（协议是可以被子类继承的。）

在OC中，无论是声明还是遵循一个协议，都有其自己的语法格式。要声明一个协议，必须使用@protocol编译器指令。下例展示了 NSCoding 协议的声明（在Foundation框架的头文件NSObject.h中）。  

	@protocol NSCoding
	- (void)encodeWithCoder:(NSCoder *)aCoder;
	- (id)initWithCoder:(NSCoder *)aDecoder;
	@end

OC2.0版本通过基于你选择声明可选协议和必选协议方法来改进了正式协议。在OC1.0版本中，采用一个协议必须实现所有该协议的方法。在OC2.0中，协议方法默认必须，但可以指定@required指令作为标记。不过你也可以使用@optional指令标记协议方法作为可选实现；所有在此指令后声明的方法，除非中间遇到@required，都可以选择是否实现。看如下声明：  

	@protocol MyProtocol
	// implementation of this method is required implicitly
	- (void)requiredMethod;
	 
	@optional
	// implementation of these methods is optional
	- (void)anOptionalMethod;
	- (void)anotherOptionalMethod;
	 
	@required
	// implementation of this method is required
	- (void)anotherRequiredMethod;
	@end

声明协议方法的类通常不用实现这些方法；不过，应该在遵循协议的类的实例中调用这些方法。在调用可选方法之前，应该使用respondsToSelector:方法检查该方法是否被实现。  
通过指定协议，一个类可以采用一个协议，包裹在一个尖括号中，在其@interface指令的末尾，跟随其父类。一个类可以采用多个协议，通过逗号分隔即可。Foundation的NSData类是如何采用三个协议的：  

	@interface NSData : NSObject <NSCopying, NSMutableCopying, NSCoding>

采用了三个协议，NSData其本身实现了在这些协议中声明的所有必须实现的方法。还可以选择实现标记为@optional的可选方法。分类也可以采用协议，并且它们的采用也会变成其类的一部分。  
OC按照类遵循的协议以及其继承的类进行分类。你可以通过发送一个conformsToProtocol: 消息来判断一个类是否遵守了一个特定协议：  

	if ([anObject conformsToProtocol:@protocol(NSCoding)]) {
	        // do something appropriate
	}

在一种类型的声明中——一个方法，实例变量或者函数——你可以指定遵循协议作为该类型的一部分。你同样获取到了另一层编译器提供的类型检查机制，这更加抽象，因为它并没有绑定到某个指定的实现上。作为遵循协议，你可以使用同样的语法约定：将协议名放在尖括号指定该类型遵循的协议。通常会看到动态对象类型，id，用在这些声明当中，比如：  

	- (void)draggingEnded:(id <NSDraggingInfo>)sender;

在这里参数中提及的对象可以为任意类型，但它必须遵循 NSDraggingInfo 协议。  
Cocoa提供了很多种协议的示范，不止目前所展示的这些。一个比较有意思的是 NSObject 协议。毫无意外的，NSObject 类遵循它，但其他根类也是如此，比如NSProxy。通过该协议，NSProxy类可以与OC运行时各个部分进行交互，这些部分对于引用计数、内省和其他基本的对象行为都至关重要。  

#### 声明属性

在对象的模型设计模式中（参见“对象模式”）对象拥有属性。属性组成了一个对象的特性，比如作为一个标题和颜色，一个对象与另一个对象的关系。在传统OC代码中，通过声明一个实例变量来定义属性，并且为了强制封装，通过实现访问器方法来获取和设置这些变量的值。这是一个乏味且容易出错的任务，尤其当内存管理是一个问题的时候（参见“存储和访问属性”）。  
在OC2.0中，在OS X v10.5中已经引入，提供了一种语法来声明属性并指定它们该如何被访问。声明一个属性变为一种声明设置和获取方法的速记方式。使用属性，你不用必须实现存取方法。通过一个点语法直接访问属性值也是可以的。属性的语法有三个方面：声明，实现和访问。  
无论是在类，分类或者协议声明部分都可以声明属性。声明属性的语法是：  

	@property(attributes...)type propertyName

当attributes是一个或多个可选属性时（如果是多个的话用逗号分隔）会影响编译器如何存储实例变量以及合成存取器方法。type元素指定一个元素的类型，声明类型或者标准类型，比如id, NSString *, NSRange, 或者 float。属性必须由一个同样类型和名称的实例变量支持。  
在属性中可选的attributes声明在列表2-1中。  

列表2-1 可以用来声明在属性中的attributes 

属性  | 效果
------------- | -------------
getter=getterName，setter=setterName  | 指定getter和setter存取器方法的名称（参见“存储和访问属性”）。当你实现你自己的存取方法并想要控制其名称时你可以指定这些属性。
readonly | 标明属性只能被读取，不能被写入。编译器不会合成setter存取方法或者允许一个非同步的方法调用。
readwrite | 标明属性能够被读写。若readonly没有指定，默认为此。
assign | 指定在实现setter方法时只需要实现赋值；这为默认。如果是声明在非垃圾回收的程序中，必须指定对象属性为retain或者copy。
retain | 指定在赋值前，retain应该发送给属性（必须为对象类型）。注意retain在垃圾自动回收环境中禁用retain。
copy | 指定在赋值前，retain应该发送给属性（必须为对象类型）。对象的类必须实现了NSCopying协议。
nonatomic | 指定存取方法合成为非原子化的方法。默认的，所有的存取方法都是原子化的：getter方法保证返回一个有效值，即使是在其他线程同时在执行。有关原子化和非原子化的属性的相关讨论，尤其是和性能相关的部分，参见《OC编程语言》的“声明属性”部分。  
如果你没指定属性并在实现中指定类@synthesize，编译器会直接使用赋值以及以propertyName作为getter setPropertyName: 作为setter名称合成属性的getter和setter方法。  
在一个类的定义的@implementation块中，你可以使用@dynamic 和 @synthesize 指令直接控制编译器对于某个属性合成存取方法。两个指令有同样的语法：  

	@dynamic propertyName [, propertyName2...];
	@synthesize propertyName [, propertyName2...];

@dynamic指令会告诉编译器你要自己为属性实现存取方法，无论是直接或者动态的（比如在动态加载代码时）。另一方面@synthesize指令告诉编译器如果存取方法没有在@implementation块中，那么就去合成存取方法。@synthesize的语法同样包含一个扩展能够让你使用不同的名称来给属性和其实例变量存储。看下如下语句：  

	@synthesize title, directReports, role = jobDescrip;

这会告诉计算机给title, directReports, 和 role合成存取方法，并使用jobDescrip实例变量返回role属性。  
最后，OC属性功能通过使用点语法和直接赋值对于存取属性支持一个简化的语法。下例展示了如何简单的使用并获取属性的值以及使用该语法对其进行设置：  

	NSString *title = employee.title; // assigns employee title to local variable
	employee.ID = "A542309"; // assigns literal string to employee ID
	// gets last name of this employee's manager
	NSString *lname = employee.manager.lastName;
	
注意点语法只在属性和简单的一对一关系中才有用，对于一对多的关系无用。  

```
扩展阅读：要更多的了解声明属性，阅读《OC编程语言》中的“声明属性”部分。
```

#### 快速枚举

快速枚举是OC2.0中引入的一项语言功能，它为你枚举一个集合提供了简单的语法。也比使用传统的 NSEnumerator 对象迭代数组、集合和字典更快。此外，它通过包含一个突变保护防止在枚举过程中修改集合，确保安全枚举。（如果尝试突变，则会抛出异常。）  
快速枚举的语法与在类似Perl和Ruby这种脚本语言中的类似；支持两个版本：  

	for ( type newVariable in expression ) { statements }

和

	type existingVariable;
	for( existingVariable in expression ) { statements }
	
expression必须必须是一个遵循NSFastEnumeration 协议的类。快速枚举的实现在OC运行时和Foundation框架中共享。Foundation框架声明了NSFastEnumeration协议，Foundation的集合类——NSArray, NSDictionary, 和 NSSet——和NSEnumerator类都采用的这一协议。其他类会持有其他对象的集合，包括自定义类也可以采用NSFastEnumeration协议来利用这一功能。  
下列代码块展示了你可以使用快速枚举在NSArray 和 NSSet 对象上：  
 
	NSArray *array = [NSArray arrayWithObjects:
	        @"One", @"Two", @"Three", @"Four", nil];
	 
	for (NSString *element in array) {
	    NSLog(@"element: %@", element);
	}
	 
	NSSet *set = [NSSet setWithObjects:
	        @"Alpha", @"Beta", @"Gamma", @"Delta", nil];
	 
	NSString *setElement;
	for (setElement in set) {
	    NSLog(@"element: %@", setElement);
	}

```
扩展阅读：要了解更多关于快速枚举，包括一个自定义集合类该如何利用这一功能，参见《OC编程语言》中的“快速枚举”一节。
```

### 使用OC

## 根类

# 给一个Cocoa程序添加行为

# Cocoa设计模式

# 与对象交互